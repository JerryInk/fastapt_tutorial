## **Неделя 3-4: Данные и валидация с Pydantic**

## Оглавление

1. [Лекция 3.1: Введение в Pydantic](#лекция-31-введение-в-pydantic---почему-это-основа-fastapi)
   - Проблема безопасности данных
   - Базовые модели Pydantic
   - Валидация данных
2. [Лекция 4.1: Интеграция Pydantic с FastAPI](#лекция-41-интеграция-pydantic-с-fastapi)
   - Request Body и Response Model
   - Обработка ошибок валидации
3. [Лекция 4.2: Продвинутые возможности Pydantic](#лекция-42-продвинутые-возможности-pydantic)
   - Наследование моделей
   - Generic модели
   - Кастомные типы данных
4. [Практические задания](#практика-31-работа-с-pydantic-моделями)

**Важно:** Все примеры в этом курсе используют **Pydantic v2** синтаксис. Если вы видите примеры с Pydantic v1, они могут не работать. FastAPI использует Pydantic v2 начиная с версии 0.100+.

---

### **Лекция 3.1: Введение в Pydantic - почему это основа FastAPI**

#### **1. Проблема: Безопасность и качество данных**

**Почему валидация критически важна:**

```python
# Пример: что может пойти без валидации

# 1. Неправильные типы
def create_user(name, age):
    # Что если age = "двадцать пять" или age = -5?
    return {"name": name, "age": age}

# 2. Отсутствие обязательных полей
def create_book(title, author, isbn):
    # Что если ISBN не передан или невалидный?
    pass

# 3. SQL-инъекции и XSS-атаки
def search_books(query):
    # Уязвимость: query = "'; DROP TABLE books; --"
    sql = f"SELECT * FROM books WHERE title LIKE '%{query}%'"
    return execute_sql(sql)
```

**Три уровня защиты данных:**
1. **Валидация на клиенте** (UI) - для удобства пользователя
2. **Валидация на сервере** (API) - **ОБЯЗАТЕЛЬНА!**
3. **Валидация в базе данных** (constraints) - последний рубеж

#### **2. Что такое Pydantic?**

**Pydantic** — это библиотека для валидации данных и управления настройками, основанная на аннотациях типов Python.

**Ключевые особенности:**
- Использует **аннотации типов Python** (type hints)
- **Автоматическая валидация** данных
- **Сериализация/десериализация** (JSON ↔ Python объекты)
- **Модели данных** (Pydantic models) - классы для валидации и сериализации
- **Настройки приложения** (через pydantic-settings)

**Почему Pydantic идеален для FastAPI:**
1. **Производительность:** Написан на Rust (ядро pydantic-core)
2. **Простота:** Использует стандартные аннотации Python
3. **Безопасность:** Защита от многих типов атак
4. **Интеграция:** Глубоко интегрирован в FastAPI

**Терминология:**
- Официально Pydantic использует термин **"модели"** (models) - классы, наследующиеся от `BaseModel`
- В структуре FastAPI проектов папку часто называют **`schemas/`** чтобы отличать от ORM моделей (которые хранятся в `models/`)
- В этом курсе мы будем использовать термин **"Pydantic модели"** в тексте, но в структуре проекта сохраним название `schemas/` как общепринятую практику

#### **3. Базовые модели Pydantic**

**Создаем первую модель:**

```python
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional
from datetime import date
from enum import Enum

# Перечисление для валидации категорий
class BookCategory(str, Enum):
    FICTION = "fiction"
    NON_FICTION = "non_fiction"
    SCIENCE = "science"
    FANTASY = "fantasy"

# Модель для книги
class Book(BaseModel):
    # Обязательные поля (без значения по умолчанию)
    title: str
    author: str
    
    # Необязательные поля (с дефолтным значением)
    year: Optional[int] = None
    pages: int = 300  # Значение по умолчанию
    
    # Поле с валидацией через Field
    price: float = Field(
        default=0.0,
        ge=0,  # greater or equal - больше или равно
        le=10000,  # less or equal - меньше или равно
        description="Цена книги в рублях"
    )
    
    # Enum поле
    category: BookCategory = BookCategory.FICTION
    
    # Дата
    published_date: Optional[date] = None
    
    # Email (специальный тип из pydantic)
    publisher_email: Optional[EmailStr] = None
    
    # Конфигурация модели (Pydantic v2 синтаксис)
    model_config = ConfigDict(
        json_schema_extra={
            "examples": [{
                "title": "Чистый код",
                "author": "Роберт Мартин",
                "year": 2008,
                "pages": 464,
                "price": 1500.0,
                "category": "science"
            }]
        }
    )
```

#### **4. Валидация данных**

**Пример валидации:**

```python
# Правильные данные
book_data = {
    "title": "1984",
    "author": "Джордж Оруэлл",
    "year": 1949,
    "price": 1200.50,
    "category": "fiction"
}

try:
    book = Book(**book_data)
    print("Книга создана:", book.model_dump())
except Exception as e:
    print("Ошибка валидации:", e)

# Неправильные данные (будут ошибки)
invalid_data = [
    {"title": 123, "author": "Автор"},  # title не строка
    {"title": "Книга", "author": "Автор", "price": -100},  # цена отрицательная
    {"title": "Книга", "author": "Автор", "category": "unknown"},  # неверная категория
    {"title": "Книга"},  # нет обязательного author
]
```

#### **5. Методы моделей Pydantic**

```python
# Создание объекта
book = Book(title="Властелин колец", author="Толкин")

# Преобразование в dict
book_dict = book.model_dump()  # {'title': 'Властелин колец', ...}
book_json = book.model_dump_json()  # '{"title": "Властелин колец", ...}'

# Создание из dict
book2 = Book.model_validate(book_dict)

# Обновление объекта
updated_book = book.model_copy(update={"price": 2000})

# Получение JSON схемы
schema = Book.model_json_schema()
print(schema)
```

### **Практика 3.1: Работа с Pydantic моделями**

**Задание 1: Создайте модели для библиотеки**

```python
from pydantic import BaseModel, Field, EmailStr, field_validator
from typing import Optional, List
from datetime import datetime
import re

class Address(BaseModel):
    street: str
    city: str
    zip_code: str = Field(..., pattern=r'^\d{6}$')  # 6 цифр
    country: str = "Россия"

class Author(BaseModel):
    id: int
    name: str = Field(..., min_length=2, max_length=100)
    email: Optional[EmailStr] = None
    birth_date: Optional[datetime] = None
    address: Optional[Address] = None
    bio: Optional[str] = Field(None, max_length=1000)

    @field_validator('name')
    @classmethod
    def name_must_contain_space(cls, v):
        if ' ' not in v:
            raise ValueError('Должно содержать имя и фамилию')
        return v.title()  # Приводим к виду "Имя Фамилия"

class BookCreate(BaseModel):  # Для создания (без id)
    title: str = Field(..., min_length=1, max_length=200)
    author_id: int
    isbn: str = Field(..., pattern=r'^\d{3}-\d-\d{3}-\d{5}-\d$')
    publication_year: int = Field(..., ge=1800, le=datetime.now().year)
    price: float = Field(..., gt=0, le=100000)
    tags: List[str] = Field(default_factory=list)
    
    @field_validator('publication_year')
    @classmethod
    def validate_publication_year(cls, v):
        """Валидация года публикации с учетом текущего года"""
        current_year = datetime.now().year
        if v > current_year:
            raise ValueError(f'Год публикации не может быть больше {current_year}')
        return v

    @field_validator('isbn')
    @classmethod
    def validate_isbn(cls, v):
        # Удаляем дефисы для проверки контрольной суммы
        digits = v.replace('-', '')
        if len(digits) != 13:
            raise ValueError('ISBN должен содержать 13 цифр')
        return v

class BookResponse(BaseModel):  # Для ответа (с id и датами)
    id: int
    title: str
    author_id: int
    isbn: str
    publication_year: int
    price: float
    tags: List[str]
    created_at: datetime
    updated_at: Optional[datetime] = None

    # Вычисляемое поле (property)
    @property
    def age(self):
        return datetime.now().year - self.publication_year
```

**Задание 2: Валидация сложных данных**

```python
from pydantic import model_validator
from typing import Any

class Order(BaseModel):
    items: List[str]
    quantities: List[int]
    total: float

    @model_validator(mode='before')
    def validate_items_and_quantities(cls, data: Any):
        if isinstance(data, dict):
            items = data.get('items', [])
            quantities = data.get('quantities', [])

            if len(items) != len(quantities):
                raise ValueError('Количество items и quantities должно совпадать')

            # Проверяем, что все количества положительные
            if any(q <= 0 for q in quantities):
                raise ValueError('Все количества должны быть > 0')
        
        return data
```

---

### **Лекция 4.1: Интеграция Pydantic с FastAPI**

#### **1. Request Body (Тело запроса)**

**Без Pydantic (опасно):**

```python
from fastapi import FastAPI, Request
import json

app = FastAPI()

@app.post("/books/")
async def create_book(request: Request):
    data = await request.json()  # Нет валидации!
    # Доверяем данным от клиента (ОПАСНО!)
    title = data.get("title")
    author = data.get("author")
    return {"title": title, "author": author}
```

**С Pydantic (безопасно):**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class BookCreate(BaseModel):
    title: str
    author: str
    year: Optional[int] = None

@app.post("/books/")
async def create_book(book: BookCreate):  # FastAPI автоматически валидирует!
    # book уже проверен и типизирован
    return {
        "message": f"Книга '{book.title}' создана",
        "data": book.model_dump()
    }
```

#### **2. Response Model (Модель ответа)**

```python
from fastapi import FastAPI, HTTPException
from typing import List
from datetime import datetime
from pydantic import BaseModel

app = FastAPI()

# Модель для ответа (скрываем чувствительные данные)
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    # Пароль НЕ включаем в ответ!
    
# Модель для базы данных (полная)
class UserInDB(BaseModel):
    id: int
    username: str
    email: str
    hashed_password: str
    is_active: bool
    created_at: datetime

@app.post("/users/", response_model=UserResponse)
async def create_user(user: UserCreate):
    # ... создаем пользователя в БД ...
    db_user = UserInDB(
        id=1,
        username=user.username,
        email=user.email,
        hashed_password="hashed_password",
        is_active=True,
        created_at=datetime.now()
    )
    
    # FastAPI автоматически преобразует UserInDB → UserResponse
    return db_user  # Пароль не будет включен в ответ!
```

#### **3. Статус коды и валидация ошибок**

```python
from fastapi import FastAPI, status
from pydantic import ValidationError
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

app = FastAPI()

# Кастомный обработчик ошибок валидации
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    errors = []
    for error in exc.errors():
        errors.append({
            "field": "->".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "detail": "Ошибка валидации данных",
            "errors": errors,
            "body": str(exc.body) if hasattr(exc, 'body') else None
        }
    )

@app.post("/books/", status_code=status.HTTP_201_CREATED)
async def create_book(book: BookCreate):
    # Если валидация пройдена, создаем книгу
    return {
        "status": "success",
        "message": "Книга создана",
        "data": book.model_dump()
    }
```

### **Практика 4.1: Полная интеграция**

**Полный пример API с валидацией:**

```python
from fastapi import FastAPI, HTTPException, Depends, status, Query, Path
from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict
from typing import Optional, List
from datetime import datetime, date

app = FastAPI(title="Библиотека API с валидацией")

# ===== МОДЕЛИ ДАННЫХ =====

class AuthorBase(BaseModel):
    name: str = Field(..., min_length=2, max_length=100)
    country: Optional[str] = None
    birth_date: Optional[date] = None

class AuthorCreate(AuthorBase):
    email: Optional[EmailStr] = None
    
    @field_validator('birth_date')
    @classmethod
    def validate_birth_date(cls, v):
        if v and v > date.today():
            raise ValueError('Дата рождения не может быть в будущем')
        return v

class AuthorResponse(AuthorBase):
    id: int
    books_count: int = 0
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)  # Для совместимости с ORM

class BookBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    publication_year: int = Field(..., ge=1800, le=datetime.now().year)
    price: float = Field(..., gt=0, description="Цена в рублях")
    in_stock: bool = True

class BookCreate(BookBase):
    author_id: int
    genres: List[str] = Field(default_factory=list, max_length=5)
    
    @field_validator('genres')
    @classmethod
    def validate_genres(cls, v):
        if v is None:
            return v
        allowed_genres = {"фантастика", "детектив", "роман", "научпоп", "биография"}
        for genre in v:
            if genre.lower() not in allowed_genres:
                raise ValueError(f'Жанр "{genre}" не поддерживается. Доступные жанры: {", ".join(allowed_genres)}')
        return v

class BookResponse(BookBase):
    id: int
    author: AuthorResponse
    genres: List[str]
    created_at: datetime
    updated_at: Optional[datetime] = None

# ===== ФИКТИВНАЯ БАЗА ДАННЫХ =====

authors_db = {}
books_db = {}
current_author_id = 1
current_book_id = 1

# ===== ENDPOINTS =====

@app.post("/authors/", 
          response_model=AuthorResponse,
          status_code=status.HTTP_201_CREATED,
          summary="Создать автора",
          description="Создает нового автора в системе",
          response_description="Информация о созданном авторе")
async def create_author(author: AuthorCreate):
    """Создание нового автора с валидацией данных"""
    global current_author_id
    
    # Проверка уникальности email
    if author.email:
        for existing_author in authors_db.values():
            if existing_author.email == author.email:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Автор с таким email уже существует"
                )
    
    # Создаем автора
    author_id = current_author_id
    author_data = {
        "id": author_id,
        "name": author.name,
        "country": author.country,
        "birth_date": author.birth_date,
        "email": author.email,
        "books_count": 0,
        "created_at": datetime.now()
    }
    
    authors_db[author_id] = author_data
    current_author_id += 1
    
    return author_data

@app.get("/authors/{author_id}", 
         response_model=AuthorResponse,
         responses={
             404: {"description": "Автор не найден"},
             422: {"description": "Ошибка валидации параметров"}
         })
async def get_author(author_id: int = Path(..., gt=0, description="ID автора")):
    """Получить информацию об авторе по ID"""
    author = authors_db.get(author_id)
    if not author:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Автор с ID {author_id} не найден"
        )
    return author

@app.post("/books/", 
          response_model=BookResponse,
          status_code=status.HTTP_201_CREATED)
async def create_book(book: BookCreate):
    """Создать новую книгу"""
    global current_book_id
    
    # Проверяем существование автора
    if book.author_id not in authors_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Автор с ID {book.author_id} не найден"
        )
    
    # Создаем книгу
    book_id = current_book_id
    book_data = {
        "id": book_id,
        "title": book.title,
        "description": book.description,
        "publication_year": book.publication_year,
        "price": book.price,
        "in_stock": book.in_stock,
        "author_id": book.author_id,
        "author": authors_db[book.author_id],
        "genres": book.genres,
        "created_at": datetime.now(),
        "updated_at": None
    }
    
    books_db[book_id] = book_data
    
    # Увеличиваем счетчик книг у автора
    authors_db[book.author_id]["books_count"] += 1
    
    current_book_id += 1
    return book_data

@app.get("/books/", response_model=List[BookResponse])
async def get_books(
    author_id: Optional[int] = Query(None, gt=0, description="Фильтр по автору"),
    genre: Optional[str] = Query(None, description="Фильтр по жанру"),
    min_price: Optional[float] = Query(None, ge=0, description="Минимальная цена"),
    max_price: Optional[float] = Query(None, ge=0, description="Максимальная цена"),
    in_stock: Optional[bool] = Query(None, description="В наличии"),
    skip: int = Query(0, ge=0, description="Количество пропущенных записей"),
    limit: int = Query(10, ge=1, le=100, description="Лимит записей")
):
    """Получить список книг с фильтрацией"""
    
    filtered_books = list(books_db.values())
    
    # Применяем фильтры
    if author_id:
        filtered_books = [b for b in filtered_books if b["author_id"] == author_id]
    
    if genre:
        filtered_books = [b for b in filtered_books if genre in b["genres"]]
    
    if min_price is not None:
        filtered_books = [b for b in filtered_books if b["price"] >= min_price]
    
    if max_price is not None:
        filtered_books = [b for b in filtered_books if b["price"] <= max_price]
    
    if in_stock is not None:
        filtered_books = [b for b in filtered_books if b["in_stock"] == in_stock]
    
    # Пагинация
    paginated_books = filtered_books[skip:skip + limit]
    
    return paginated_books

class BookUpdate(BaseModel):
    """Модель для частичного обновления книги"""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    publication_year: Optional[int] = Field(None, ge=1800, le=datetime.now().year)
    price: Optional[float] = Field(None, gt=0, description="Цена в рублях")
    in_stock: Optional[bool] = None
    author_id: Optional[int] = None
    genres: Optional[List[str]] = Field(None, max_length=5)

@app.patch("/books/{book_id}", response_model=BookResponse)
async def update_book(
    book_id: int = Path(..., gt=0, description="ID книги"),
    book_update: Optional[BookUpdate] = None  # Модель с Optional полями для PATCH
):
    """Частичное обновление книги"""
    if book_id not in books_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Книга с ID {book_id} не найдена"
        )
    
    if book_update is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Необходимо передать хотя бы одно поле для обновления"
        )
    
    current_book = books_db[book_id]
    
    # Обновляем только переданные поля
    update_data = book_update.model_dump(exclude_unset=True)
    
    # Специальная обработка author_id
    if "author_id" in update_data:
        new_author_id = update_data["author_id"]
        if new_author_id != current_book["author_id"]:
            # Проверяем нового автора
            if new_author_id not in authors_db:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Автор с ID {new_author_id} не найден"
                )
            # Обновляем счетчики
            authors_db[current_book["author_id"]]["books_count"] -= 1
            authors_db[new_author_id]["books_count"] += 1
    
    # Применяем обновления
    for field, value in update_data.items():
        if field != "author_id":  # author_id обработали отдельно
            current_book[field] = value
    
    current_book["updated_at"] = datetime.now()
    
    return current_book
```

### **Лекция 4.2: Продвинутые возможности Pydantic**

#### **1. Наследование моделей**

```python
from pydantic import BaseModel, ConfigDict
from datetime import datetime

# Базовая модель с общими полями
class TimestampMixin(BaseModel):
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = ConfigDict(from_attributes=True)

# Базовые модели для наследования
class BookBase(BaseModel):
    title: str
    author: str

class BookCreate(BookBase):
    pass  # Дополнительные поля для создания

class BookUpdate(BookBase):
    title: Optional[str] = None  # Все поля необязательные для обновления
    author: Optional[str] = None

class BookInDB(BookBase, TimestampMixin):
    id: int
    is_active: bool = True
    
    # Переопределяем конфигурацию
    model_config = ConfigDict(
        from_attributes=True,
        json_schema_extra={
            "example": {
                "id": 1,
                "title": "Пример книги",
                "author": "Автор",
                "created_at": "2024-01-15T10:00:00",
                "is_active": True
            }
        }
    )
```

#### **2. Generic модели для типизации**

```python
from typing import Generic, TypeVar, Optional
from pydantic import BaseModel

T = TypeVar('T')  # Generic тип

class PaginatedResponse(BaseModel, Generic[T]):
    items: List[T]
    total: int
    page: int
    size: int
    pages: int
    
    @classmethod
    def create(cls, items: List[T], total: int, page: int, size: int):
        pages = (total + size - 1) // size  # ceil division
        return cls(
            items=items,
            total=total,
            page=page,
            size=size,
            pages=pages
        )

# Использование
class BookResponse(BaseModel):
    id: int
    title: str

@app.get("/books/paginated", response_model=PaginatedResponse[BookResponse])
async def get_books_paginated(
    page: int = 1,
    size: int = 10
):
    books = list(books_db.values())
    total = len(books)
    start = (page - 1) * size
    end = start + size
    paginated_books = books[start:end]
    
    return PaginatedResponse.create(
        items=paginated_books,
        total=total,
        page=page,
        size=size
    )
```

#### **3. Кастомные типы данных**

```python
from pydantic import BaseModel, field_validator
import re

class PhoneNumber(str):
    """Кастомный тип для номера телефона"""
    
    @classmethod
    def __get_pydantic_core_schema__(cls, source_type, handler):
        # Используем стандартную валидацию строки
        from pydantic_core import core_schema
        return core_schema.with_info_after_validator_function(
            cls.validate,
            handler(str),
        )
    
    @classmethod
    def validate(cls, v: str, info):
        # Проверяем формат номера телефона
        pattern = r'^\+7\d{10}$|^8\d{10}$'
        if not re.match(pattern, v):
            raise ValueError('Неверный формат номера телефона. Используйте формат: +7XXXXXXXXXX или 8XXXXXXXXXX')
        
        # Нормализуем номер
        normalized = '+7' + v[1:] if v.startswith('8') else v
        
        return cls(normalized)
    
    def format(self):
        """Форматированный вывод номера"""
        return f"{self[:2]} ({self[2:5]}) {self[5:8]}-{self[8:10]}-{self[10:]}"

class UserWithPhone(BaseModel):
    name: str
    phone: PhoneNumber

# Использование
user = UserWithPhone(name="Иван", phone="+79161234567")
print(user.phone.format())  # +7 (916) 123-45-67
```

#### **4. Валидаторы и пред/пост-обработка**

```python
from pydantic import BaseModel, field_validator, model_validator
from typing import Any

class Order(BaseModel):
    items: List[str]
    quantities: List[int]
    unit_prices: List[float]
    discount: float = 0.0
    total: Optional[float] = None  # Вычисляемое поле
    
    # Валидатор для конкретного поля
    @field_validator('discount')
    @classmethod
    def validate_discount(cls, v):
        if v < 0 or v > 1:
            raise ValueError('Скидка должна быть между 0 и 1')
        return v
    
    # Валидатор для нескольких полей
    @model_validator(mode='before')
    @classmethod
    def validate_all_arrays_same_length(cls, data: Any):
        if isinstance(data, dict):
            items = data.get('items', [])
            quantities = data.get('quantities', [])
            unit_prices = data.get('unit_prices', [])
            
            if len(items) != len(quantities) or len(items) != len(unit_prices):
                raise ValueError('Все массивы должны иметь одинаковую длину')
        
        return data
    
    # Пост-обработка (после валидации)
    @model_validator(mode='after')
    def calculate_total(self):
        total = sum(q * p for q, p in zip(self.quantities, self.unit_prices))
        total_with_discount = total * (1 - self.discount)
        # В Pydantic v2 используем object.__setattr__ для установки значения
        object.__setattr__(self, 'total', total_with_discount)
        return self
    
    # Вычисляемое свойство
    @property
    def item_count(self):
        return len(self.items)
```

### **Практика 4.2: Комплексное задание**

**Задание: Система регистрации пользователей с полной валидацией**

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, EmailStr, field_validator, model_validator, ConfigDict
from typing import Optional, Dict
from datetime import datetime, date
import re

app = FastAPI()

class Password(str):
    """Кастомный тип для пароля"""
    
    @classmethod
    def __get_pydantic_core_schema__(cls, source_type, handler):
        from pydantic_core import core_schema
        return core_schema.with_info_after_validator_function(
            cls.validate,
            handler(str),
        )
    
    @classmethod
    def validate(cls, v: str, info):
        """Валидация пароля с проверкой сложности"""
        if not isinstance(v, str):
            raise ValueError("Пароль должен быть строкой")
        
        errors = []
        
        # Минимальная длина
        if len(v) < 8:
            errors.append("Пароль должен содержать минимум 8 символов")
        
        # Проверка сложности
        if not re.search(r'[A-Z]', v):
            errors.append("Пароль должен содержать хотя бы одну заглавную букву")
        
        if not re.search(r'[a-z]', v):
            errors.append("Пароль должен содержать хотя бы одну строчную букву")
        
        if not re.search(r'\d', v):
            errors.append("Пароль должен содержать хотя бы одну цифру")
        
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            errors.append("Пароль должен содержать хотя бы один специальный символ")
        
        if errors:
            raise ValueError("; ".join(errors))
        
        return cls(v)

class UserRegistration(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, pattern=r'^[a-zA-Z0-9_]+$')
    email: EmailStr
    password: Password
    confirm_password: str
    birth_date: date = Field(..., description="Дата рождения")
    
    @field_validator('birth_date')
    @classmethod
    def validate_birth_date(cls, v):
        today = date.today()
        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        
        if age < 18:
            raise ValueError('Пользователь должен быть старше 18 лет')
        if age > 120:
            raise ValueError('Некорректная дата рождения')
        
        return v
    
    @model_validator(mode='after')
    def check_passwords_match(self):
        if self.password != self.confirm_password:
            raise ValueError('Пароли не совпадают')
        return self
    
    @property
    def age(self):
        today = date.today()
        return today.year - self.birth_date.year - (
            (today.month, today.day) < (self.birth_date.month, self.birth_date.day)
        )

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    age: int
    is_active: bool
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)

# "База данных"
users_db: Dict[int, dict] = {}
current_id = 1

@app.post("/register/", response_model=UserResponse, status_code=201)
async def register_user(user_data: UserRegistration):
    global current_id
    
    # Проверка уникальности
    for user in users_db.values():
        if user['username'] == user_data.username:
            raise HTTPException(400, "Пользователь с таким именем уже существует")
        if user['email'] == user_data.email:
            raise HTTPException(400, "Пользователь с таким email уже существует")
    
    # Создаем пользователя
    user_id = current_id
    user_record = {
        "id": user_id,
        "username": user_data.username,
        "email": user_data.email,
        "password": f"hashed_{user_data.password}",  # В реальности хешируем!
        "age": user_data.age,
        "is_active": True,
        "created_at": datetime.now()
    }
    
    users_db[user_id] = user_record
    current_id += 1
    
    return user_record
```

### **Чек-лист понимания материала:**

Перед выполнением домашнего задания убедитесь, что вы понимаете:

- [ ] Как создавать базовые Pydantic модели с валидацией
- [ ] Разницу между `field_validator` и `model_validator`
- [ ] Как использовать `Field` для дополнительных ограничений
- [ ] Как разделять модели на Create/Update/Response
- [ ] Как интегрировать Pydantic модели с FastAPI endpoints
- [ ] Как обрабатывать ошибки валидации
- [ ] Как создавать кастомные типы данных
- [ ] Как использовать Generic модели для пагинации

### **Домашнее задание на недели 3-4:**

**Часть 1: Создание моделей**
1. Создайте полную систему моделей для интернет-магазина:
   - Product (товар) с категориями, ценами, скидками
   - Order (заказ) с элементами заказа, доставкой, оплатой
   - User (пользователь) с адресом доставки, историей заказов
   - Review (отзыв) с рейтингом, текстом, датой

2. Реализуйте:
   - Наследование моделей
   - Кастомные валидаторы
   - Вычисляемые поля (total_price, average_rating)
   - Сложные constraints (скидка не более 70%, рейтинг 1-5)

**Часть 2: Интеграция с FastAPI**
1. Создайте CRUD API для продуктов:
   - POST /products/ (создание с валидацией)
   - GET /products/ (список с фильтрацией по цене, категории)
   - GET /products/{id} (детальная информация)
   - PATCH /products/{id} (частичное обновление)
   - DELETE /products/{id} (мягкое удаление - is_active=False)

2. Реализуйте пагинацию с Generic-моделью

3. Добавьте кастомные обработчики ошибок валидации

**Часть 3: Продвинутая валидация**
1. Создайте валидатор для российского ИНН (10 или 12 цифр с контрольной суммой)
2. Реализуйте валидацию банковской карты (номер, срок, CVV)
3. Создайте систему скидок с проверкой:
   - Скидка не может превышать цену товара
   - Накопительные скидки с учетом истории покупок
   - Сезонные скидки по датам

**Бонусное задание:**
Создайте систему валидации заказа, которая проверяет:
1. Наличие товаров на складе
2. Совместимость доставки и адреса
3. Возрастные ограничения для некоторых товаров
4. Промокоды и их сроки действия

### **Ключевые выводы недель 3-4:**

1. **Pydantic** — мощная система валидации данных, основанная на аннотациях типов
2. **Разделение моделей** на Create/Update/Response улучшает безопасность и читаемость
3. **FastAPI автоматически** использует Pydantic для валидации запросов и сериализации ответов
4. **Кастомные валидаторы** позволяют реализовать сложную бизнес-логику
5. **Generic модели** делают код типизированным и переиспользуемым
6. **Обработка ошибок** валидации должна быть информативной для клиентов API

В следующий раз мы будем использовать эти модели с реальной базой данных и добавим аутентификацию!

---

## **Полезные ресурсы:**

- [Официальная документация Pydantic v2](https://docs.pydantic.dev/)
- [FastAPI: Request Body](https://fastapi.tiangolo.com/tutorial/body/)
- [FastAPI: Response Model](https://fastapi.tiangolo.com/tutorial/response-model/)
- [Pydantic: Field Validators](https://docs.pydantic.dev/latest/concepts/validators/)
- [Pydantic: Custom Types](https://docs.pydantic.dev/latest/concepts/types/)

---

<!--
## Дополнительные рекомендации для дальнейшего улучшения материала:

1. **Добавить больше примеров валидации:**
   - Валидация URL и URI
   - Валидация JSON схем
   - Валидация с использованием внешних библиотек (например, phonenumbers для телефонов)

2. **Расширить раздел про производительность:**
   - Сравнение производительности Pydantic v1 и v2
   - Оптимизация валидации для больших объемов данных
   - Использование `model_validate` vs `parse_obj`

3. **Добавить раздел про миграцию с Pydantic v1 на v2:**
   - Основные изменения в API
   - Как обновить существующий код
   - Частые проблемы при миграции

4. **Улучшить примеры с кастомными типами:**
   - Более сложные примеры валидации
   - Интеграция с внешними библиотеками
   - Примеры валидации бизнес-логики

5. **Добавить раздел про тестирование Pydantic моделей:**
   - Unit-тесты для валидаторов
   - Тестирование моделей с pytest
   - Моки и фикстуры для моделей
-->