# **Неделя 5-6: Структура проекта, Dependencies и Dependency Injection**

## Оглавление

1. [Лекция 5.1: Структура проекта — от хаоса к порядку](#лекция-51-структура-проекта--от-хаоса-к-порядку)
   - Проблема "Spaghetti-кода"
   - Принципы хорошей структуры
   - Стандартная структура FastAPI проекта
2. [Лекция 5.2: Dependency Injection в FastAPI](#лекция-52-dependency-injection-в-fastapi)
   - Что такое Dependency Injection
   - Типы зависимостей в FastAPI
   - Function, Class и Generator Dependencies
3. [Лекция 6.1: Практические паттерны использования Dependencies](#лекция-61-практические-паттерны-использования-dependencies)
   - Проверка прав доступа
   - Кэширование и Rate Limiting
   - Валидация запросов
4. [Лекция 6.2: Полная структура проекта с зависимостями](#лекция-62-полная-структура-проекта-с-зависимостями)
   - Полный пример библиотечного приложения
5. [Практические задания](#практическое-задание-на-недели-5-6)

---

## **Лекция 5.1: Структура проекта — от хаоса к порядку**

**Почему структура проекта важна:**
- **Поддерживаемость** — легко найти нужный код
- **Масштабируемость** — просто добавлять новые функции
- **Тестируемость** — можно тестировать компоненты изолированно
- **Работа в команде** — минимизация конфликтов
- **Переиспользование** — код можно использовать в разных местах

### **1. Проблема: "Spaghetti-код" в одном файле**

**Пример плохой структуры (main.py на 500 строк):**
```python
# ВСЁ В ОДНОМ ФАЙЛЕ - АНТИПАТТЕРН!
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional
import sqlite3
import os
import json
from datetime import datetime
import jwt
from passlib.context import CryptContext
import smtplib
from email.mime.text import MIMEText

# Модели, БД, роутеры, бизнес-логика, утилиты - ВСЁ ВМЕСТЕ!
app = FastAPI()

# Конфигурация разбросана по файлу
DATABASE_URL = "sqlite:///./test.db"
SECRET_KEY = "secret"
SMTP_SERVER = "smtp.gmail.com"

# 100 строк моделей Pydantic
class UserCreate(BaseModel): ...
class UserResponse(BaseModel): ...
class BookCreate(BaseModel): ...
class BookResponse(BaseModel): ...

# Функции для работы с БД между роутерами
def get_db(): ...
def hash_password(password): ...
def verify_token(token): ...

# Роутеры пользователей
@app.post("/users/")
async def create_user(): ...
@app.get("/users/{user_id}")
async def get_user(): ...

# Роутеры книг  
@app.get("/books/")
async def get_books(): ...
@app.post("/books/")
async def create_book(): ...

# Утилиты отправки email
def send_email(): ...

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**Проблемы:**
- ❌ Невозможно тестировать отдельные компоненты
- ❌ Сложно находить код
- ❌ Конфликты при работе в команде
- ❌ Запутанные зависимости между компонентами
- ❌ Невозможно переиспользовать код
- ❌ Сложное поддержание

### **2. Принципы хорошей структуры проекта**

**Аналогия:** Представьте библиотеку. Книги не свалены в одну кучу, а организованы по:
- **Разделам** (художественная, научная, детская)
- **Полкам** (по авторам, по темам)
- **Каталогам** (для быстрого поиска)

Так и код должен быть организован логично и предсказуемо.

#### **Принцип единственной ответственности (SRP - Single Responsibility Principle)**

**Определение:** Каждый модуль/класс должен иметь одну и только одну причину для изменения.

**Пример:**
```python
# ПЛОХО: класс делает слишком много
class UserManager:
    def create_user(self): ...      # Работа с БД
    def send_email(self): ...       # Отправка email
    def validate_password(self): ... # Валидация
    def generate_report(self): ...   # Генерация отчетов

# ХОРОШО: каждый класс делает одну вещь
class UserRepository:
    def create_user(self): ...      # Только работа с БД

class EmailService:
    def send_email(self): ...       # Только отправка email

class PasswordValidator:
    def validate_password(self): ... # Только валидация
```

#### **Принцип разделения ответственности**

**Идея:** Разделяйте код по его назначению, а не по типу (все функции вместе, все классы вместе).
- **app/** - FastAPI приложение и конфигурация
- **api/** - роутеры и endpoints
- **core/** - настройки, константы, утилиты
- **models/** - SQLAlchemy модели (ORM модели для работы с БД)
- **schemas/** - Pydantic модели (для валидации и сериализации данных API)
  - *Примечание: В структуре проекта папку часто называют `schemas/` чтобы отличать от ORM моделей, но технически это Pydantic модели (BaseModel)*
- **services/** - бизнес-логика
- **repositories/** - работа с БД (CRUD)
- **dependencies/** - зависимости FastAPI

#### **Архитектурные паттерны:**

**1. Многослойная архитектура (Layered Architecture)**
```
┌─────────────────────────────────┐
│   Presentation Layer (API)      │ ← Endpoints, роутеры
├─────────────────────────────────┤
│   Business Logic Layer          │ ← Сервисы, бизнес-логика
├─────────────────────────────────┤
│   Data Access Layer             │ ← Репозитории, работа с БД
├─────────────────────────────────┤
│   Database                      │ ← База данных
└─────────────────────────────────┘
```
**Преимущества:** Четкое разделение ответственности, легко тестировать каждый слой.

**2. Clean Architecture / Hexagonal Architecture**
- **Внутренний слой:** Бизнес-логика (не зависит от внешних библиотек)
- **Внешний слой:** Инфраструктура (БД, API, внешние сервисы)
- **Порты и адаптеры:** Интерфейсы для взаимодействия между слоями

**Преимущества:** Бизнес-логика независима от фреймворков и БД, легко менять технологии.

**3. Repository Pattern + Service Pattern**
- **Repository:** Абстракция доступа к данным (скрывает детали БД)
- **Service:** Бизнес-логика, использует репозитории

**Преимущества:** Легко тестировать (можно мокировать репозитории), легко менять БД.

### **3. Стандартная структура FastAPI проекта**

```
fastapi_project/
├── .env                    # Переменные окружения (не в git)
├── .gitignore
├── pyproject.toml         # Зависимости и настройки
├── requirements.txt       # Альтернатива pyproject.toml
├── README.md
│
├── app/                   # Основное приложение
│   ├── __init__.py
│   ├── main.py           # Точка входа FastAPI
│   │
│   ├── api/              # Роутеры (endpoints)
│   │   ├── __init__.py
│   │   ├── v1/           # Версия API v1
│   │   │   ├── __init__.py
│   │   │   ├── endpoints/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── books.py
│   │   │   │   ├── users.py
│   │   │   │   └── auth.py
│   │   │   └── api.py    # Объединение всех роутеров v1
│   │   └── deps.py       # Общие зависимости
│   │
│   ├── core/             # Ядро приложения
│   │   ├── __init__.py
│   │   ├── config.py     # Конфигурация
│   │   ├── security.py   # Аутентификация, JWT
│   │   └── database.py   # Подключение к БД
│   │
│   ├── models/           # SQLAlchemy модели
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── book.py
│   │
│   ├── schemas/          # Pydantic модели (для валидации данных)
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── book.py
│   │
│   ├── services/         # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── user_service.py
│   │   └── book_service.py
│   │
│   ├── repositories/     # Работа с БД (опционально)
│   │   ├── __init__.py
│   │   ├── user_repo.py
│   │   └── book_repo.py
│   │
│   ├── utils/            # Вспомогательные функции
│   │   ├── __init__.py
│   │   └── email.py
│   │
│   └── dependencies/     # Зависимости FastAPI
│       ├── __init__.py
│       └── database.py
│
├── tests/               # Тесты
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_api/
│   └── test_services/
│
├── alembic/             # Миграции БД (если используем)
│   ├── versions/
│   └── env.py
│
└── scripts/             # Вспомогательные скрипты
    ├── init_db.py
    └── create_admin.py
```

### **4. Детальный разбор структуры**

#### **app/main.py — точка входа:**
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.v1.api import api_router
from app.core.config import settings
from app.core.database import engine, Base
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Создание таблиц БД (в разработке)
# В production используем миграции Alembic
# Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
)

# CORS middleware
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Подключаем роутеры
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    """Корневой endpoint для проверки работы API"""
    return {
        "message": f"Добро пожаловать в {settings.PROJECT_NAME}",
        "version": settings.VERSION,
        "docs": "/docs",
        "health": "/health"
    }

@app.get("/health")
async def health_check():
    """Проверка здоровья приложения"""
    from datetime import datetime, timezone
    return {
        "status": "healthy",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
```

#### **app/core/config.py — управление конфигурацией:**

**Зачем нужен отдельный файл конфигурации:**
- Централизованное управление настройками
- Безопасное хранение секретов (через переменные окружения)
- Валидация настроек при старте приложения
- Разные конфигурации для dev/staging/production

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional
from dotenv import load_dotenv

# Загружаем .env файл (опционально, pydantic-settings может загружать сам)
load_dotenv()

class Settings(BaseSettings):
    # Основные настройки
    PROJECT_NAME: str = "FastAPI Library"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    
    # Безопасность
    SECRET_KEY: str = "your-secret-key-here-change-in-production"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # База данных
    DATABASE_URL: str = "sqlite:///./library.db"
    
    # CORS
    BACKEND_CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://localhost:8000"]
    
    # Настройки SMTP для email
    SMTP_HOST: Optional[str] = None
    SMTP_PORT: Optional[int] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None
    
    # Режим отладки
    DEBUG: bool = False
    
    # Валидация настроек (Pydantic v2 синтаксис)
    model_config = SettingsConfigDict(
        case_sensitive=True,
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore"  # Игнорировать лишние переменные окружения
    )
    
    @property
    def async_database_url(self):
        """URL для асинхронного подключения к БД"""
        if self.DATABASE_URL.startswith("sqlite"):
            return self.DATABASE_URL.replace("sqlite://", "sqlite+aiosqlite://")
        elif self.DATABASE_URL.startswith("postgresql"):
            return self.DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://")
        return self.DATABASE_URL

# Создаем глобальный экземпляр настроек
settings = Settings()

# Для тестирования можно создать разные конфигурации
class TestSettings(Settings):
    DATABASE_URL: str = "sqlite:///./test.db"
    DEBUG: bool = True
```

#### **app/core/database.py — подключение к БД:**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from typing import AsyncGenerator, Generator
from app.core.config import settings

# Синхронный движок (для миграций, админки)
sync_engine = create_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)

# Асинхронный движок (для основного приложения)
# Примечание: SQLAlchemy 2.0+ не требует future=True
async_engine = create_async_engine(
    settings.async_database_url,
    echo=settings.DEBUG,
)

# Сессии
SyncSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=sync_engine)

# Асинхронные сессии (SQLAlchemy 2.0+)
from sqlalchemy.ext.asyncio import async_sessionmaker
AsyncSessionLocal = async_sessionmaker(
    async_engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# Базовый класс для моделей
Base = declarative_base()

# Dependency для получения сессии БД
def get_db() -> Generator[Session, None, None]:
    """Синхронная сессия для legacy кода"""
    db = SyncSessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    """Асинхронная сессия - рекомендуется для FastAPI
    
    Примечание: Использует async_sessionmaker из SQLAlchemy 2.0+
    Автоматически управляет жизненным циклом сессии:
    - Открывает сессию при входе
    - Коммитит изменения при успехе
    - Откатывает при ошибке
    - Закрывает сессию в finally
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# Инициализация БД
def init_db():
    """Создание таблиц (только для разработки)"""
    Base.metadata.create_all(bind=sync_engine)
```

---

## **Лекция 5.2: Dependency Injection в FastAPI**

### **1. Что такое Dependency Injection (DI)?**

**Определение:** Dependency Injection (DI) — это паттерн проектирования, при котором зависимости объекта предоставляются извне, а не создаются внутри самого объекта.

**Аналогия:** Представьте ресторан:
- **Без DI:** Повар сам идет на рынок, покупает продукты, готовит и подает блюдо
- **С DI:** Повару приносят готовые продукты (зависимости), он только готовит

**Преимущества DI:**
- **Тестируемость** — легко подменить зависимости на моки
- **Гибкость** — можно менять реализации без изменения кода
- **Переиспользование** — зависимости можно использовать в разных местах
- **Читаемость** — явно видно, от чего зависит компонент

**Проблема без DI (жесткие зависимости):**
```python
# ПЛОХО: жесткая зависимость
class EmailService:
    def __init__(self):
        self.smtp_server = "smtp.gmail.com"
        self.port = 587
        self.username = "admin@gmail.com"
        self.password = "password123"
    
    def send_email(self, to, subject, body):
        # Прямое создание зависимости
        server = smtplib.SMTP(self.smtp_server, self.port)
        # ... код отправки

class UserService:
    def __init__(self):
        # Жесткая зависимость - сложно тестировать!
        self.email_service = EmailService()
    
    def register_user(self, user_data):
        # ... регистрация
        self.email_service.send_email(...)  # Зависимость
```

**Решение с DI (внедрение зависимостей):**
```python
# ХОРОШО: зависимости внедряются
class EmailService:
    def __init__(self, smtp_server, port, username, password):
        self.smtp_server = smtp_server
        # ... инициализация
    
    def send_email(self, to, subject, body):
        # ... отправка

class UserService:
    def __init__(self, email_service: EmailService):  # Зависимость внедряется
        self.email_service = email_service
    
    def register_user(self, user_data):
        # ... регистрация
        self.email_service.send_email(...)

# Создаем зависимости и внедряем их
email_service = EmailService(config.SMTP_HOST, config.SMTP_PORT, ...)
user_service = UserService(email_service)  # ВНЕДРЕНИЕ
```

### **2. Dependency Injection в FastAPI**

**Почему FastAPI имеет встроенную DI:**
FastAPI использует систему зависимостей на основе аннотаций типов Python. Это позволяет автоматически:
- Разрешать зависимости по типам
- Внедрять зависимости в endpoints
- Управлять жизненным циклом (например, открытие/закрытие соединений с БД)

**Как это работает:**
1. FastAPI анализирует аннотации типов параметров функции
2. Ищет зависимости, указанные через `Depends()`
3. Рекурсивно разрешает все зависимости
4. Вызывает функцию с внедренными зависимостями

**Пример простой зависимости:**
```python
from fastapi import Depends

def get_database():
    return "database_connection"

@app.get("/items/")
async def read_items(db: str = Depends(get_database)):
    # db автоматически получает значение из get_database()
    return {"db": db}
```

FastAPI имеет **встроенную систему DI**, которая:
- Автоматически разрешает зависимости
- Позволяет переиспользовать код
- Упрощает тестирование
- Управляет жизненным циклом зависимостей

#### **Типы зависимостей в FastAPI:**

1. **Function Dependencies** — функции-зависимости
2. **Class Dependencies** — классы как зависимости
3. **Generator Dependencies** — для управления ресурсами (БД, файлы)
4. **Parameter Dependencies** — зависимости с параметрами

### **3. Function Dependencies**

**Базовый пример:**
```python
from fastapi import Depends, FastAPI, HTTPException
from typing import Optional

app = FastAPI()

# Простая зависимость
def common_parameters(
    q: Optional[str] = None, 
    skip: int = 0, 
    limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # commons автоматически заполняется из query parameters
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # Та же зависимость переиспользуется
    return {"users": [], "filters": commons}
```

**Зависимости с бизнес-логикой:**
```python
from fastapi import Depends, Header, HTTPException, status
from typing import Optional

async def verify_token(x_token: Optional[str] = Header(None)):
    """Зависимость для проверки токена"""
    if not x_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Токен не предоставлен"
        )
    
    # В реальности проверяем токен в БД или кэше
    if x_token != "secret-token":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Неверный токен"
        )
    
    return {"user_id": 1, "username": "admin"}

async def get_current_user(
    token_data: dict = Depends(verify_token),
    x_user_id: Optional[int] = Header(None)
):
    """Зависимость для получения текущего пользователя"""
    # Можем добавить дополнительную логику
    user_id = token_data["user_id"]
    
    # Проверяем совпадение user_id из токена и заголовка
    if x_user_id and x_user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ запрещен"
        )
    
    return {
        "id": user_id,
        "username": token_data["username"],
        "permissions": ["read", "write"]
    }

@app.get("/protected/")
async def protected_route(current_user: dict = Depends(get_current_user)):
    """Защищенный маршрут"""
    return {
        "message": f"Привет, {current_user['username']}!",
        "user": current_user
    }
```

### **4. Class Dependencies**

```python
from fastapi import Depends, Query
from typing import Optional, List

class PaginationParams:
    """Класс-зависимость для пагинации"""
    
    def __init__(
        self,
        page: int = Query(1, ge=1, description="Номер страницы"),
        size: int = Query(10, ge=1, le=100, description="Размер страницы"),
        sort_by: Optional[str] = Query(None, description="Поле для сортировки"),
        sort_order: Optional[str] = Query(None, regex="^(asc|desc)$")
    ):
        self.page = page
        self.size = size
        self.sort_by = sort_by
        self.sort_order = sort_order
        self.skip = (page - 1) * size
        
    def apply_to_query(self, query, model_class):
        """Применяет пагинацию и сортировку к SQLAlchemy запросу
        
        Args:
            query: SQLAlchemy запрос (Select объект)
            model_class: Класс модели SQLAlchemy для сортировки
            
        Returns:
            Модифицированный запрос с примененной сортировкой и пагинацией
            
        Пример:
            query = select(Book)
            pagination = PaginationParams(page=1, size=10, sort_by="title", sort_order="asc")
            query = pagination.apply_to_query(query, Book)
            result = await db.execute(query)
        """
        if self.sort_by and hasattr(model_class, self.sort_by):
            sort_field = getattr(model_class, self.sort_by)
            if self.sort_order == "desc":
                order = sort_field.desc()
            else:
                order = sort_field.asc()
            query = query.order_by(order)
        
        return query.offset(self.skip).limit(self.size)

@app.get("/books/")
async def get_books(
    pagination: PaginationParams = Depends(PaginationParams),
    genre: Optional[str] = None,
    author_id: Optional[int] = None
):
    """Получить книги с пагинацией и фильтрацией"""
    # Используем параметры пагинации
    # Примечание: в реальном коде передайте класс модели Book в apply_to_query
    query = build_query(genre, author_id)
    # query = pagination.apply_to_query(query, model_class=Book)
    query = query.offset(pagination.skip).limit(pagination.size)
    
    total = await count_books(genre, author_id)
    books = await execute_query(query)
    
    return {
        "items": books,
        "page": pagination.page,
        "size": pagination.size,
        "total": total,
        "pages": (total + pagination.size - 1) // pagination.size
    }
```

### **5. Generator Dependencies (для ресурсов)**

```python
from contextlib import asynccontextmanager
from typing import AsyncGenerator
import aiosqlite

# Зависимость для подключения к SQLite
@asynccontextmanager
async def get_sqlite_connection() -> AsyncGenerator[aiosqlite.Connection, None]:
    """Контекстный менеджер для подключения к БД"""
    connection = await aiosqlite.connect("database.db")
    try:
        yield connection
    finally:
        await connection.close()

# Зависимость для сессии БД с использованием генератора
async def get_db_session(
    connection: aiosqlite.Connection = Depends(get_sqlite_connection)
) -> AsyncGenerator[aiosqlite.Cursor, None]:
    """Зависимость для получения курсора БД"""
    async with connection.cursor() as cursor:
        try:
            yield cursor
            await connection.commit()
        except Exception:
            await connection.rollback()
            raise

@app.post("/books/")
async def create_book(
    book_data: BookCreate,
    cursor: aiosqlite.Cursor = Depends(get_db_session)
):
    """Создание книги с зависимостью БД"""
    await cursor.execute(
        "INSERT INTO books (title, author) VALUES (?, ?)",
        (book_data.title, book_data.author)
    )
    book_id = cursor.lastrowid
    
    return {"id": book_id, **book_data.model_dump()}
```

---

## **Лекция 6.1: Практические паттерны использования Dependencies**

### **1. Dependency для проверки прав доступа**

**Проблема:** Разные endpoints требуют разных уровней доступа. Нужно проверять права пользователя.

**Решение:** Создаем переиспользуемую зависимость для проверки ролей.

**Преимущества:**
- Один раз написали — используем везде
- Легко тестировать
- Явно видно, какие права нужны для endpoint

```python
from fastapi import Depends, HTTPException, status
from typing import List

class RoleChecker:
    """Зависимость для проверки ролей пользователя
    
    Использование:
        allow_admin = RoleChecker(["admin"])
        
        @app.get("/admin/")
        async def admin_route(user: dict = Depends(allow_admin)):
            ...
    """
    
    def __init__(self, allowed_roles: List[str]):
        """Инициализация с списком разрешенных ролей"""
        self.allowed_roles = allowed_roles
    
    def __call__(self, current_user: dict = Depends(get_current_user)):
        """Проверяет, есть ли у пользователя нужная роль"""
        if current_user.get("role") not in self.allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Недостаточно прав. Требуются роли: {', '.join(self.allowed_roles)}"
            )
        return current_user

# Создаем зависимости для разных уровней доступа
allow_admin = RoleChecker(["admin"])
allow_manager = RoleChecker(["admin", "manager"])
allow_user = RoleChecker(["admin", "manager", "user"])

@app.get("/admin/dashboard")
async def admin_dashboard(
    current_user: dict = Depends(allow_admin)  # Только админы
):
    return {"message": "Админ панель", "user": current_user}

@app.get("/manager/reports")
async def manager_reports(
    current_user: dict = Depends(allow_manager)  # Админы и менеджеры
):
    return {"message": "Отчеты", "user": current_user}
```

### **2. Кэширование с зависимостями**

```python
from typing import Optional, Any
import redis.asyncio as redis
from fastapi import Depends
from functools import lru_cache

# Зависимость для Redis
async def get_redis() -> redis.Redis:
    """Подключение к Redis"""
    # Примечание: в реальном приложении используйте пул соединений
    return await redis.from_url("redis://localhost:6379", decode_responses=True)

class CacheManager:
    """Менеджер кэширования с зависимостью Redis"""
    
    def __init__(self, redis_client: redis.Redis = Depends(get_redis)):
        self.redis = redis_client
    
    async def get(self, key: str) -> Optional[Any]:
        """Получить значение из кэша"""
        return await self.redis.get(key)
    
    async def set(self, key: str, value: Any, expire: int = 300):
        """Сохранить значение в кэш"""
        await self.redis.setex(key, expire, str(value))
    
    async def invalidate(self, pattern: str):
        """Удалить ключи по паттерну"""
        keys = await self.redis.keys(pattern)
        if keys:
            await self.redis.delete(*keys)

# Зависимость для кэширования ответов API
async def cache_response(
    cache_key: str,
    cache_manager: CacheManager = Depends(CacheManager),
    expire: int = 60
):
    """Декоратор-зависимость для кэширования"""
    
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # Пытаемся получить из кэша
            cached = await cache_manager.get(cache_key)
            if cached:
                return cached
            
            # Выполняем функцию
            result = await func(*args, **kwargs)
            
            # Сохраняем в кэш
            await cache_manager.set(cache_key, result, expire)
            
            return result
        return wrapper
    return decorator

# Примечание: декоратор cache_response в примере выше имеет проблемы с реализацией
# В реальном приложении используйте middleware или отдельную зависимость
@app.get("/expensive-operation/")
async def expensive_operation():
    """Дорогая операция с кэшированием"""
    import time
    import asyncio
    await asyncio.sleep(2)  # Имитация долгой асинхронной операции
    return {"result": "data", "computed_at": time.time()}
```

### **3. Валидация запросов с зависимостями**

**Зачем:** Сложная валидация параметров запроса (например, проверка диапазона дат, взаимосвязи параметров).

**Преимущества:** Валидация вынесена в отдельный класс, можно переиспользовать.

```python
from fastapi import Depends, Query, HTTPException
from typing import Optional
from datetime import date

class DateRangeValidator:
    """Валидация диапазона дат
    
    Проверяет:
    - Что start_date раньше end_date
    - Что диапазон не превышает max_range_days
    """
    
    def __init__(
        self,
        start_date: Optional[date] = Query(None, description="Начальная дата"),
        end_date: Optional[date] = Query(None, description="Конечная дата"),
        max_range_days: int = 365
    ):
        self.start_date = start_date
        self.end_date = end_date
        self.max_range_days = max_range_days
        
        # Валидация выполняется при создании объекта
        self.validate()
    
    def validate(self):
        """Проверяет корректность диапазона дат"""
        if self.start_date and self.end_date:
            if self.start_date > self.end_date:
                raise HTTPException(
                    status_code=400, 
                    detail="start_date должен быть раньше end_date"
                )
            
            delta = (self.end_date - self.start_date).days
            if delta > self.max_range_days:
                raise HTTPException(
                    status_code=400, 
                    detail=f"Диапазон дат не может превышать {self.max_range_days} дней"
                )
    
    @property
    def has_range(self):
        return self.start_date and self.end_date
    
    @property
    def range_days(self):
        if self.has_range:
            return (self.end_date - self.start_date).days
        return 0

@app.get("/statistics/")
async def get_statistics(
    date_range: DateRangeValidator = Depends(DateRangeValidator),
    metric: str = Query("revenue", regex="^(revenue|users|orders)$")
):
    """Получение статистики с валидацией дат"""
    
    query_filters = {}
    if date_range.has_range:
        query_filters.update({
            "start_date": date_range.start_date,
            "end_date": date_range.end_date
        })
    
    # Получаем статистику
    stats = await calculate_statistics(metric, **query_filters)
    
    return {
        "metric": metric,
        "date_range": {
            "start": date_range.start_date,
            "end": date_range.end_date,
            "days": date_range.range_days
        } if date_range.has_range else None,
        "statistics": stats
    }
```

### **4. Rate Limiting с зависимостями**

**Зачем нужен Rate Limiting:**
- Защита от DDoS атак
- Предотвращение злоупотребления API
- Справедливое распределение ресурсов
- Защита от брутфорс атак

**Примечание:** В production используйте Redis для распределенного rate limiting.

```python
import time
from collections import defaultdict
from fastapi import Depends, HTTPException, Request
from typing import Dict

class RateLimiter:
    """Ограничитель запросов
    
    Примечание: Это упрощенная версия для демонстрации.
    В production используйте Redis или специализированные библиотеки
    (например, slowapi для FastAPI).
    """
    
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        # Храним историю запросов по IP адресам
        self.requests: Dict[str, list] = defaultdict(list)
    
    async def __call__(self, request: Request):
        """Проверяет лимит запросов для текущего клиента"""
        client_ip = request.client.host if request.client else "unknown"
        current_time = time.time()
        
        # Очищаем старые запросы (старше 1 минуты)
        self.requests[client_ip] = [
            req_time for req_time in self.requests[client_ip]
            if current_time - req_time < 60
        ]
        
        # Проверяем лимит
        if len(self.requests[client_ip]) >= self.requests_per_minute:
            raise HTTPException(
                status_code=429,
                detail="Слишком много запросов. Попробуйте позже.",
                headers={"Retry-After": "60"}
            )
        
        # Добавляем текущий запрос
        self.requests[client_ip].append(current_time)
        
        return {
            "remaining": self.requests_per_minute - len(self.requests[client_ip]),
            "reset_in": 60 - (current_time - self.requests[client_ip][0]) if self.requests[client_ip] else 0
        }

# Создаем ограничители с разными лимитами
public_rate_limiter = RateLimiter(requests_per_minute=30)
authenticated_rate_limiter = RateLimiter(requests_per_minute=100)
admin_rate_limiter = RateLimiter(requests_per_minute=1000)

@app.get("/public/")
async def public_endpoint(
    rate_limit: dict = Depends(public_rate_limiter)
):
    """Публичный endpoint с ограничением 30 запросов в минуту"""
    return {
        "message": "Публичные данные",
        "rate_limit": rate_limit
    }

@app.get("/api/data/")
async def api_data(
    current_user: dict = Depends(get_current_user),
    rate_limit: dict = Depends(authenticated_rate_limiter)
):
    """Защищенный endpoint с лимитом 100 запросов в минуту"""
    return {
        "message": "Данные API",
        "user": current_user,
        "rate_limit": rate_limit
    }
```

---

## **Лекция 6.2: Полная структура проекта с зависимостями**

### **Полный пример: библиотечное приложение**

#### **1. Структура файлов:**
```
library_app/
├── app/
│   ├── main.py
│   ├── api/
│   │   ├── v1/
│   │   │   ├── endpoints/
│   │   │   │   ├── books.py
│   │   │   │   ├── users.py
│   │   │   │   └── auth.py
│   │   │   └── api.py
│   ├── core/
│   │   ├── config.py
│   │   ├── security.py
│   │   └── database.py
│   ├── models/
│   │   ├── book.py
│   │   └── user.py
│   ├── schemas/
│   │   ├── book.py
│   │   └── user.py
│   ├── services/
│   │   ├── book_service.py
│   │   └── user_service.py
│   ├── dependencies/
│   │   ├── database.py
│   │   ├── auth.py
│   │   └── commons.py
│   └── utils/
│       └── pagination.py
```

#### **2. app/dependencies/database.py:**
```python
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import AsyncSessionLocal

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Зависимость для получения сессии БД"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

#### **3. app/dependencies/auth.py:**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from app.core.config import settings
from app.services.user_service import UserService
from app.dependencies.database import get_db
from sqlalchemy.ext.asyncio import AsyncSession

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/v1/auth/login")

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> dict:
    """Получить текущего пользователя из токена"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Не удалось подтвердить учетные данные",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        user_id: int = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user_service = UserService(db)
    user = await user_service.get_by_id(user_id)
    
    if user is None:
        raise credentials_exception
    
    return user

async def get_current_active_user(
    current_user: dict = Depends(get_current_user)
) -> dict:
    """Получить текущего активного пользователя"""
    if not current_user.get("is_active"):
        raise HTTPException(status_code=400, detail="Пользователь неактивен")
    return current_user

class RoleChecker:
    """Проверка ролей пользователя"""
    
    def __init__(self, allowed_roles: list):
        self.allowed_roles = allowed_roles
    
    def __call__(self, current_user: dict = Depends(get_current_active_user)):
        if current_user.get("role") not in self.allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Недостаточно прав"
            )
        return current_user

# Создаем зависимости для разных ролей
allow_admin = RoleChecker(["admin"])
allow_librarian = RoleChecker(["admin", "librarian"])
allow_reader = RoleChecker(["admin", "librarian", "reader"])
```

#### **4. app/dependencies/commons.py:**
```python
from fastapi import Query, Depends
from typing import Optional
from app.utils.pagination import PaginationParams

async def get_pagination_params(
    page: int = Query(1, ge=1, description="Номер страницы"),
    size: int = Query(10, ge=1, le=100, description="Размер страницы"),
    sort_by: Optional[str] = Query(None, description="Поле для сортировки"),
    sort_order: Optional[str] = Query("asc", regex="^(asc|desc)$")
) -> PaginationParams:
    """Параметры пагинации для списков"""
    return PaginationParams(
        page=page,
        size=size,
        sort_by=sort_by,
        sort_order=sort_order
    )

async def get_search_params(
    q: Optional[str] = Query(None, description="Поисковый запрос"),
    category: Optional[str] = Query(None, description="Категория"),
    min_price: Optional[float] = Query(None, ge=0, description="Минимальная цена"),
    max_price: Optional[float] = Query(None, ge=0, description="Максимальная цена")
) -> dict:
    """Параметры поиска и фильтрации"""
    return {
        "search_query": q,
        "category": category,
        "min_price": min_price,
        "max_price": max_price
    }
```

#### **5. app/api/v1/endpoints/books.py:**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession

from app.schemas.book import BookCreate, BookUpdate, BookResponse
from app.services.book_service import BookService
from app.dependencies.database import get_db
from app.dependencies.auth import allow_librarian, allow_reader
from app.dependencies.commons import get_pagination_params, get_search_params
from app.utils.pagination import PaginationParams

router = APIRouter(prefix="/books", tags=["books"])

@router.get("/", response_model=List[BookResponse])
async def get_books(
    pagination: PaginationParams = Depends(get_pagination_params),
    filters: dict = Depends(get_search_params),
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(allow_reader)  # Проверка прав
):
    """Получить список книг с пагинацией и фильтрацией"""
    book_service = BookService(db)
    books = await book_service.get_all(
        skip=pagination.skip,
        limit=pagination.size,
        **filters
    )
    return books

@router.get("/{book_id}", response_model=BookResponse)
async def get_book(
    book_id: int,
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(allow_reader)
):
    """Получить книгу по ID"""
    book_service = BookService(db)
    book = await book_service.get_by_id(book_id)
    
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Книга с ID {book_id} не найдена"
        )
    
    return book

@router.post("/", response_model=BookResponse, status_code=status.HTTP_201_CREATED)
async def create_book(
    book_data: BookCreate,
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(allow_librarian)  # Только библиотекари
):
    """Создать новую книгу"""
    book_service = BookService(db)
    
    # Проверяем, существует ли уже книга с таким ISBN
    existing_book = await book_service.get_by_isbn(book_data.isbn)
    if existing_book:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Книга с таким ISBN уже существует"
        )
    
    # Создаем книгу
    book = await book_service.create(
        book_data=book_data,
        created_by=current_user["id"]
    )
    
    return book

@router.put("/{book_id}", response_model=BookResponse)
async def update_book(
    book_id: int,
    book_data: BookUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(allow_librarian)
):
    """Обновить информацию о книге"""
    book_service = BookService(db)
    
    # Проверяем существование книги
    existing_book = await book_service.get_by_id(book_id)
    if not existing_book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Книга с ID {book_id} не найдена"
        )
    
    # Обновляем книгу
    updated_book = await book_service.update(
        book_id=book_id,
        book_data=book_data,
        updated_by=current_user["id"]
    )
    
    return updated_book

@router.delete("/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_book(
    book_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(allow_admin)  # Только админы
):
    """Удалить книгу"""
    book_service = BookService(db)
    
    # Проверяем существование книги
    existing_book = await book_service.get_by_id(book_id)
    if not existing_book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Книга с ID {book_id} не найдена"
        )
    
    # Удаляем книгу (мягкое удаление)
    await book_service.delete(book_id=book_id)
    
    return None
```

#### **6. app/api/v1/api.py:**
```python
from fastapi import APIRouter
from app.api.v1.endpoints import books, users, auth

api_router = APIRouter()

# Подключаем все роутеры
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(books.router, prefix="/books", tags=["books"])

# Можно добавлять версионирование
# api_router.include_router(v2.router, prefix="/v2")
```

#### **7. app/services/book_service.py:**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from typing import List, Optional
from datetime import datetime

from app.models.book import Book
from app.schemas.book import BookCreate, BookUpdate

class BookService:
    """Сервис для работы с книгами"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        search_query: Optional[str] = None,
        category: Optional[str] = None,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None
    ) -> List[Book]:
        """Получить все книги с фильтрацией"""
        query = select(Book).where(Book.is_deleted == False)
        
        # Применяем фильтры
        filters = []
        
        if search_query:
            filters.append(
                or_(
                    Book.title.ilike(f"%{search_query}%"),
                    Book.author.ilike(f"%{search_query}%"),
                    Book.description.ilike(f"%{search_query}%")
                )
            )
        
        if category:
            filters.append(Book.category == category)
        
        if min_price is not None:
            filters.append(Book.price >= min_price)
        
        if max_price is not None:
            filters.append(Book.price <= max_price)
        
        if filters:
            query = query.where(and_(*filters))
        
        # Применяем пагинацию
        query = query.offset(skip).limit(limit).order_by(Book.created_at.desc())
        
        result = await self.db.execute(query)
        return result.scalars().all()
    
    async def get_by_id(self, book_id: int) -> Optional[Book]:
        """Получить книгу по ID"""
        query = select(Book).where(
            and_(Book.id == book_id, Book.is_deleted == False)
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_isbn(self, isbn: str) -> Optional[Book]:
        """Получить книгу по ISBN"""
        query = select(Book).where(
            and_(Book.isbn == isbn, Book.is_deleted == False)
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
    
    async def create(
        self, 
        book_data: BookCreate,
        created_by: int
    ) -> Book:
        """Создать новую книгу"""
        db_book = Book(
            **book_data.model_dump(),
            created_by=created_by,
            created_at=datetime.now(timezone.utc)
        )
        
        self.db.add(db_book)
        await self.db.commit()
        await self.db.refresh(db_book)
        
        return db_book
    
    async def update(
        self,
        book_id: int,
        book_data: BookUpdate,
        updated_by: int
    ) -> Book:
        """Обновить информацию о книге"""
        book = await self.get_by_id(book_id)
        if not book:
            return None
        
        # Обновляем только переданные поля
        update_data = book_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(book, field, value)
        
        book.updated_by = updated_by
        book.updated_at = datetime.now(timezone.utc)
        
        await self.db.commit()
        await self.db.refresh(book)
        
        return book
    
    async def delete(self, book_id: int) -> bool:
        """Мягкое удаление книги"""
        book = await self.get_by_id(book_id)
        if not book:
            return False
        
        book.is_deleted = True
        book.deleted_at = datetime.now(timezone.utc)
        
        await self.db.commit()
        return True
```

### **Практическое задание на недели 5-6:**

**Часть 1: Создание структуры проекта**
1. Создайте проект с полной структурой папок как показано выше
2. Реализуйте конфигурацию через pydantic-settings с поддержкой .env файла
3. Настройте подключение к PostgreSQL с использованием asyncpg

**Часть 2: Реализация зависимостей**
1. Создайте систему зависимостей для:
   - Аутентификации пользователя (JWT)
   - Проверки ролей (admin, user, guest)
   - Пагинации и сортировки
   - Rate limiting (60 запросов в минуту для анонимов, 200 для авторизованных)
   - Кэширования часто запрашиваемых данных

2. Реализуйте зависимости для:
   - Валидации email перед отправкой
   - Генерации PDF отчетов
   - Отправки уведомлений в Telegram

**Часть 3: Сервис для управления заказами**
1. Создайте полную цепочку зависимостей для системы заказов:
   ```
   Заказ → Проверка наличия товара → Проверка баланса пользователя → 
   Применение скидок → Создание заказа → Отправка уведомлений
   ```

2. Каждый шаг должен быть отдельной зависимостью

**Часть 4: Тестирование зависимостей**
1. Напишите тесты для всех зависимостей
2. Протестируйте сценарии:
   - Успешная аутентификация
   - Недостаточно прав
   - Превышение лимита запросов
   - Ошибка валидации данных

**Бонусное задание:**
Создайте систему плагинов с зависимостями, где можно динамически подключать:
1. Разные способы оплаты (карта, PayPal, криптовалюта)
2. Разные способы доставки (курьер, почта, самовывоз)
3. Разные провайдеры уведомлений (email, SMS, push)

### **Ключевые выводы недель 5-6:**

1. **Структура проекта** — основа поддерживаемости и масштабируемости
   - Организация по функциональности, а не по типу файлов
   - Четкое разделение слоев (API, бизнес-логика, данные)

2. **Dependency Injection** — мощный паттерн для управления зависимостями
   - Упрощает тестирование
   - Повышает гибкость кода
   - Улучшает читаемость

3. **FastAPI DI система** — простая в использовании, но очень гибкая
   - Автоматическое разрешение зависимостей
   - Управление жизненным циклом ресурсов
   - Поддержка разных типов зависимостей

4. **Разделение ответственности** — каждый модуль делает одну вещь и делает её хорошо
   - Принцип единственной ответственности (SRP)
   - Легче поддерживать и тестировать

5. **Зависимости** можно использовать для:
   - Аутентификации и авторизации
   - Валидации данных
   - Кэширования
   - Rate limiting
   - Пагинации и сортировки
   - Управления ресурсами (БД, файлы)

6. **Контекстные менеджеры** (генераторы) идеально подходят для управления ресурсами
   - Автоматическое открытие/закрытие соединений
   - Обработка ошибок и откат транзакций

**Правила хорошего тона:**
- Держите зависимости маленькими и сфокусированными
- Используйте классы для сложных зависимостей с состоянием
- Всегда закрывайте ресурсы в finally-блоке
- Документируйте зависимости в docstrings
- Тестируйте зависимости изолированно
- Используйте типизацию для лучшей поддержки IDE и проверки типов