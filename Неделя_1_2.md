## **Неделя 1-2: Введение в современный Python для веба и FastAPI**

## Оглавление

1. [Лекция 1.1: HTTP и основы веб-API](#лекция-11)
   - Что такое API
   - Структура HTTP-запросов и ответов
   - HTTP-методы и коды состояния
2. [Лекция 1.2: REST архитектура](#лекция-12-rest---архитектурный-стиль-для-веб-сервисов)
   - Принципы REST
   - Проектирование RESTful API
3. [Лекция 1.3: Введение в FastAPI](#лекция-13-почему-fastapi-сравнение-с-flask-и-django)
   - Сравнение с Flask и Django
   - Установка и первое приложение
4. [Практические задания](#практика-11-изучаем-http-на-практике)

---

### **Лекция 1.1**

#### **1. Что такое API и зачем он нужен?**
*   **API (Application Programming Interface)** — это набор правил и инструментов, который позволяет одним приложениям взаимодействовать с другими.
*   **Веб-API (Web API)** — API, использующий протокол HTTP.
*   **Аналогия:** Представьте ресторан. Меню — это API. Вы (клиент) делаете заказ (запрос) по определенному формату (название блюда, порция). Кухня (сервер) получает заказ, готовит и возвращает вам блюдо (ответ). Вам не нужно знать, как именно работает кухня.

#### **2. Что такое HTTP?**

**HTTP (HyperText Transfer Protocol)** — это протокол прикладного уровня для передачи гипертекстовых документов. Простыми словами: **язык, на котором говорят браузеры и серверы**.

**Аналогия:** Представьте заказ в ресторане:
- Вы (клиент) говорите официанту (запрос): "Я хочу пиццу Маргарита"
- Официант передает заказ на кухню (сервер)
- Кухня готовит и возвращает через официанта (ответ): "Ваша пицца готова"

#### **3. Структура HTTP-запроса**

**Пример реального HTTP-запроса:**
```http
GET /api/books/123 HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0
Accept: application/json
Authorization: Bearer token123
# Content-Type не нужен для GET запросов
```

**Из чего состоит:**
1. **Стартовая строка:**
   - Метод: `GET`
   - Путь: `/api/books/123`
   - Версия протокола: `HTTP/1.1`

2. **Заголовки (Headers):**
   - `Host` - домен сервера
   - `User-Agent` - информация о клиенте
   - `Accept` - какие типы данных клиент понимает
   - `Authorization` - токен для доступа
   - `Content-Type` - тип отправляемых данных (используется для POST, PUT, PATCH запросов)

3. **Тело (Body) - опционально:**
   - Для `POST`, `PUT` запросов
   ```json
   {"title": "Новая книга", "author": "Автор"}
   ```

#### **4. Структура HTTP-ответа**

**Пример ответа:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 45
Server: nginx/1.18
Date: Mon, 15 Jan 2024 10:00:00 GMT

{"id": 123, "title": "Чистый код", "author": "Р. Мартин"}
```

**Из чего состоит:**
1. **Строка статуса:**
   - Версия: `HTTP/1.1`
   - Код статуса: `200`
   - Пояснение: `OK`

2. **Заголовки (Headers)**

3. **Тело (Body) - опционально**

#### **5. Основные HTTP-методы (глаголы)**

| Метод  | Описание | Идемпотентен* | Безопасный | Пример |
|:-------|:---------|:--------------|:-----------|:-------|
| **GET** | Получить данные | Да | Да | `GET /api/books` |
| **POST** | Создать новый ресурс | Нет | Нет | `POST /api/books` |
| **PUT** | Полностью обновить ресурс | Да | Нет | `PUT /api/books/123` |
| **PATCH** | Частично обновить ресурс | Нет | Нет | `PATCH /api/books/123` |
| **DELETE** | Удалить ресурс | Да | Нет | `DELETE /api/books/123` |
| **OPTIONS** | Получить доступные методы | Да | Да | `OPTIONS /api/books` |

*Идемпотентность — свойство операции: повторное выполнение дает тот же результат.

#### **6. Коды состояния HTTP (Status Codes)**

**Группы кодов:**
- **1xx (Информационные)**: Запрос принят, продолжается обработка
- **2xx (Успех)**: Запрос успешно обработан
  - `200 OK` - успешный запрос
  - `201 Created` - ресурс создан
  - `204 No Content` - успешно, но нет тела ответа
- **3xx (Перенаправления)**: Требуются дополнительные действия
  - `301 Moved Permanently` - постоянное перенаправление
  - `302 Found` - временное перенаправление
- **4xx (Ошибка клиента)**: Ошибка на стороне клиента
  - `400 Bad Request` - неверный запрос
  - `401 Unauthorized` - требуется аутентификация
  - `403 Forbidden` - доступ запрещен
  - `404 Not Found` - ресурс не найден
  - `422 Unprocessable Entity` - данные не прошли валидацию (использует FastAPI!)
- **5xx (Ошибка сервера)**: Ошибка на стороне сервера
  - `500 Internal Server Error` - общая ошибка сервера
  - `502 Bad Gateway` - проблемы с прокси/шлюзом
  - `503 Service Unavailable` - сервис временно недоступен

### **Практика 1.1: Изучаем HTTP на практике**

**Инструменты для тестирования:**
1. **curl** - консольная утилита
2. **httpie** - современная альтернатива curl
3. **Postman/Insomnia** - графические клиенты
4. **Браузер DevTools** - вкладка Network

**Установка httpie (рекомендуется для курса):**
```bash
pip install httpie
```

**Примеры запросов:**

**Синтаксис httpie:**
- `==` для query параметров
- `=` для JSON body
- `:` для заголовков

```bash
# 1. GET запрос
http GET http://httpbin.org/get

# 2. GET с query параметрами (используйте ==)
http GET http://httpbin.org/get name=="John" age==25

# 3. POST запрос с JSON body (используйте =)
http POST http://httpbin.org/post name="John" age=25

# 4. POST с заголовками (используйте :)
http POST http://httpbin.org/post \
  Content-Type:application/json \
  Authorization:"Bearer token123" \
  name="John"

# 5. GET с заголовком
http GET http://httpbin.org/get Authorization:"Bearer token123"

# 6. Удаление
http DELETE http://httpbin.org/delete

# 7. Скачать файл
http -d GET http://httpbin.org/image/jpeg
```

**Практическое задание:**
```bash
# Исследуйте публичные API
http GET https://api.github.com/users/octocat
http GET https://jsonplaceholder.typicode.com/posts/1
http GET https://api.agify.io name==ivan
```

---

### **Лекция 1.2: REST - Архитектурный стиль для веб-сервисов**

#### **1. Что такое REST?**
**REST (Representational State Transfer)** — это набор принципов и ограничений для построения распределенных систем. Это **не протокол**, а **архитектурный стиль**.

**Ключевая идея:** Все — это ресурсы, которые имеют уникальные идентификаторы (URI) и могут быть представлены в разных форматах.

#### **2. 6 ограничений REST (Constraints)**

1. **Единообразие интерфейса (Uniform Interface)**
   - Идентификация ресурсов (URI)
   - Манипуляция ресурсами через представления
   - Самодостаточные сообщения
   - Гипермедиа как движок состояния приложения (HATEOAS)

2. **Без состояния (Stateless)**
   - Каждый запрос содержит всю информацию для его обработки
   - Сервер не хранит состояние клиента между запросами

3. **Кэшируемость (Cacheable)**
   - Ответы должны явно указывать, можно ли их кэшировать

4. **Клиент-серверная архитектура**
   - Четкое разделение ответственности

5. **Многоуровневая система (Layered System)**
   - Клиент не знает, подключен ли он к конечному серверу или к промежуточному

6. **Код по требованию (Code on Demand) - опционально**
   - Сервер может временно расширять функциональность клиента

#### **3. Ресурсы и URI (URL) в REST**

**Ресурс** — любой объект, данные или сервис, доступный клиенту.

**Примеры RESTful URI:**
```
# Коллекция книг
GET    /api/books           # Получить все книги
POST   /api/books           # Создать новую книгу

# Конкретная книга
GET    /api/books/123       # Получить книгу с id=123
PUT    /api/books/123       # Полностью обновить книгу 123
PATCH  /api/books/123       # Частично обновить книгу 123
DELETE /api/books/123       # Удалить книгу 123

# Вложенные ресурсы
GET    /api/books/123/comments  # Комментарии к книге 123
POST   /api/books/123/comments  # Добавить комментарий к книге 123
```

**Хорошие практики именования:**
- Используйте существительные во множественном числе: `/books`, а не `/getBooks`
- Избегайте глаголов в URI: `/books`, а не `/getBooks`
- Используйте вложенность для отношений: `/books/{id}/comments`
- Версионирование API: `/api/v1/books`

#### **4. Представления ресурсов (Representations)**

Один ресурс может быть представлен в разных форматах:

```http
# Клиент запрашивает JSON
GET /api/books/123
Accept: application/json

# Ответ:
Content-Type: application/json
{"id": 123, "title": "Книга", "format": "JSON"}

# Тот же ресурс в XML
GET /api/books/123
Accept: application/xml

# Ответ:
Content-Type: application/xml
<book><id>123</id><title>Книга</title><format>XML</format></book>
```

#### **5. HATEOAS - Hypermedia as the Engine of Application State**

**Идея:** Клиент взаимодействует с API только через гиперссылки, предоставляемые сервером.

**Пример ответа с HATEOAS:**
```json
{
  "id": 123,
  "title": "Чистый код",
  "author": "Р. Мартин",
  "_links": {
    "self": {"href": "/api/books/123"},
    "comments": {"href": "/api/books/123/comments"},
    "author": {"href": "/api/authors/456"},
    "purchase": {"href": "/store/books/123"}
  }
}
```

#### **6. REST vs RPC (Remote Procedure Call)**

| Аспект | REST (Ресурсо-ориентированный) | RPC (Действие-ориентированный) |
|--------|--------------------------------|--------------------------------|
| **Подход** | Работа с ресурсами | Вызов функций/методов |
| **URI** | `/api/books/123` | `/api/getBook` или `/api/updateBook` |
| **Методы** | Использует HTTP-методы | Часто только POST |
| **Пример** | `DELETE /api/books/123` | `POST /api/deleteBook` с `{"id": 123}` |
| **Состояние** | Статус в HTTP-методе | Статус в теле запроса |

### **Практика 1.2: Проектируем RESTful API**

**Задание:** Спроектировать API для библиотеки

**1. Определяем ресурсы:**
- Книги (books)
- Авторы (authors)
- Читатели (readers)
- Заказы (orders)

**2. Проектируем endpoints:**

```yaml
# Книги
GET    /api/books                    # Список книг с фильтрацией
POST   /api/books                    # Добавить книгу
GET    /api/books/{id}               # Получить книгу
PUT    /api/books/{id}               # Обновить книгу
PATCH  /api/books/{id}               # Частично обновить
DELETE /api/books/{id}               # Удалить книгу
GET    /api/books/{id}/author        # Автор книги

# Авторы
GET    /api/authors
POST   /api/authors
GET    /api/authors/{id}
GET    /api/authors/{id}/books       # Книги автора

# Читатели
GET    /api/readers
POST   /api/readers
GET    /api/readers/{id}
GET    /api/readers/{id}/orders      # Заказы читателя

# Заказы
GET    /api/orders
POST   /api/orders
GET    /api/orders/{id}
PATCH  /api/orders/{id}/status       # Обновить статус заказа
```

**3. Определяем форматы данных:**

**Запрос на создание книги (POST /api/books):**
```json
{
  "title": "Новая книга",
  "author_id": 456,
  "isbn": "978-5-4461-1234-5",
  "publication_year": 2023
}
```

**Ответ (201 Created):**
```json
{
  "id": 789,
  "title": "Новая книга",
  "author_id": 456,
  "isbn": "978-5-4461-1234-5",
  "publication_year": 2023,
  "created_at": "2024-01-15T10:00:00Z",
  "_links": {
    "self": {"href": "/api/books/789"},
    "author": {"href": "/api/authors/456"}
  }
}
```

### **Демонстрация: Создаем простейший REST API на чистом Python**

**`simple_http_server.py`:**
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import urllib.parse

# Простая база данных в памяти
books_db = [
    {"id": 1, "title": "Чистый код", "author": "Р. Мартин"},
    {"id": 2, "title": "1984", "author": "Дж. Оруэлл"},
]

class SimpleAPIHandler(BaseHTTPRequestHandler):
    
    def _set_headers(self, status_code=200, content_type='application/json'):
        self.send_response(status_code)
        self.send_header('Content-Type', content_type)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
    
    def do_GET(self):
        parsed_path = urllib.parse.urlparse(self.path)
        path = parsed_path.path
        
        # GET /api/books
        if path == '/api/books':
            self._set_headers()
            self.wfile.write(json.dumps(books_db).encode())
        
        # GET /api/books/{id}
        elif path.startswith('/api/books/'):
            try:
                book_id = int(path.split('/')[-1])
                book = next((b for b in books_db if b['id'] == book_id), None)
                
                if book:
                    self._set_headers()
                    self.wfile.write(json.dumps(book).encode())
                else:
                    self._set_headers(404)
                    self.wfile.write(json.dumps({"error": "Book not found"}).encode())
            except ValueError:
                self._set_headers(400)
                self.wfile.write(json.dumps({"error": "Invalid book ID"}).encode())
        
        else:
            self._set_headers(404)
            self.wfile.write(json.dumps({"error": "Endpoint not found"}).encode())
    
    def do_POST(self):
        if self.path == '/api/books':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            
            try:
                new_book = json.loads(post_data.decode())
                new_book['id'] = max((b['id'] for b in books_db), default=0) + 1
                books_db.append(new_book)
                
                self._set_headers(201)
                self.wfile.write(json.dumps(new_book).encode())
            except json.JSONDecodeError:
                self._set_headers(400)
                self.wfile.write(json.dumps({"error": "Invalid JSON"}).encode())
        else:
            self._set_headers(404)

def run_server():
    server_address = ('', 8000)
    httpd = HTTPServer(server_address, SimpleAPIHandler)
    print('Сервер запущен на http://localhost:8000')
    print('Доступные endpoints:')
    print('  GET  /api/books')
    print('  GET  /api/books/{id}')
    print('  POST /api/books')
    httpd.serve_forever()

if __name__ == '__main__':
    run_server()
```

**Запустите и протестируйте:**
```bash
python simple_http_server.py

# В другом терминале тестируем:
http GET http://localhost:8000/api/books
http GET http://localhost:8000/api/books/1
http POST http://localhost:8000/api/books title="Новая книга" author="Автор"
```

### **Ключевые выводы:**

1. **HTTP** — это протокол передачи данных, основанный на запросах и ответах
2. **REST** — это архитектурный стиль, использующий HTTP для работы с ресурсами
3. **Ресурсы** идентифицируются URI и представляются в разных форматах
4. **HTTP-методы** определяют действие над ресурсом
5. **Коды состояния** сообщают о результате операции
6. **Хорошее API** предсказуемо, последовательно и документировано

На следующей неделе мы начнем использовать FastAPI, который автоматически реализует многие REST-принципы и значительно упрощает создание веб-API!

### **Лекция 1.3: Почему FastAPI? Сравнение с Flask и Django**
*   **FastAPI (Молодой и быстрый):**
    *   Высокая производительность (на уровне Node.js и Go), благодаря асинхронности и использованию **Starlette** (ASGI-фреймворк).
    *   **Автоматическая документация** (Swagger UI, ReDoc) из аннотаций типов.
    *   Встроенная **валидация данных** через Pydantic.
    *   Современный: основан на аннотациях типов Python (type hints).
    *   Лучше для создания именно API (микро-сервисов), а не монолитных приложений с шаблонами.

*   **Flask (Простой и гибкий):**
    *   Минималистичный, "микро"-фреймворк. Вы сами выбираете инструменты для БД, валидации и т.д.
    *   Синхронный по умолчанию (хотя есть расширения для async).
    *   Документацию и валидацию нужно настраивать вручную или через расширения.
    *   Отлично подходит для небольших проектов и прототипов.

*   **Django (Монолитный и "все включено"):**
    *   "Фреймворк для perfectionist с дедлайнами". Включает ORM, админ-панель, систему аутентификации, шаблонизатор.
    *   Имеет **Django REST Framework (DRF)** — мощный, но более тяжеловесный инструмент для создания API.
    *   Отличный выбор для больших, комплексных проектов, где нужны "батарейки в комплекте".

**4. Введение в асинхронность (`async`/`await`):**

*   **Синхронный код:** Операции выполняются последовательно. Если одна операция ждет (например, запрос к БД или другому API), весь сервер "засыпает" на это время.
*   **Асинхронный код:** Позволяет серверу переключаться на выполнение других задач, пока одна ждет ответа (I/O-bound операции). Это как официант, который принимает заказы от многих столиков, пока кухня готовит.

**Пример сравнения:**

```python
import time
import asyncio

# Синхронный код (блокирующий)
def get_data_sync():
    time.sleep(2)  # Блокирует весь сервер на 2 секунды
    return {"data": "result"}

# Асинхронный код (неблокирующий)
async def get_data_async():
    await asyncio.sleep(2)  # Позволяет обрабатывать другие запросы
    return {"data": "result"}
```

*   Ключевые слова:
    *   `async def` — объявляет асинхронную функцию (корутину).
    *   `await` — "ожидание" результата асинхронной операции без блокировки потока.
*   **Важно:** FastAPI может работать и с синхронными функциями, но для реального преимущества в производительности под нагрузкой используйте `async`.

### **Практика 1.3**

#### **1. Установка и первое приложение:**

##### **Шаг 1: Классический (venv + pip) - рекомендуется для начала**

```bash
# 1. Проверяем версию Python (должна быть 3.10+ для лучшей поддержки)
# FastAPI официально поддерживает Python 3.8+, но рекомендуется 3.10+
# Примечание: FastAPI полностью поддерживает Python 3.12. Если у вас установлена версия 3.12, это отлично подходит для курса.

python --version
# или
python3 --version

# 2. Создаем директорию для проекта
mkdir fastapi_course
cd fastapi_course

# 3. Создаем виртуальное окружение
# На Windows:
python -m venv venv

# На macOS/Linux:
python3 -m venv venv
# или
python -m venv venv

# 4. Активируем виртуальное окружение
# На Windows (Command Prompt):
venv\Scripts\activate.bat
# На Windows (PowerShell):
.\venv\Scripts\Activate.ps1
# (Если возникает ошибка выполнения скриптов, выполните в PowerShell: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser)

# На macOS/Linux:
source venv/bin/activate

# Признак успешной активации - в начале строки терминала появится (venv)
(venv) C:\fastapi_course>
```

##### **Шаг 2: Установка FastAPI и зависимостей**

###### **Базовый вариант:**

```bash
pip install "fastapi[all]"
```

**Что устанавливает `[all]`:**
- `uvicorn` - ASGI-сервер для запуска приложения
- `pydantic` - для валидации данных (уже входит в fastapi)
- `pydantic-settings` - для управления настройками
- `starlette` - веб-фреймворк, на котором построен FastAPI
- `typing-extensions` - поддержка новых аннотаций типов
- `fastapi-cli` - CLI инструменты
- `httpx` - HTTP клиент для тестирования
- `pytest` - фреймворк для тестирования
- и другие полезные dev-инструменты

###### **Расширенный вариант (рекомендуется для курса):**

```bash
# Создайте файл requirements.txt в корне проекта:
# Внимание: Версии указаны на январь 2026. 
# Перед установкой проверьте актуальные версии на PyPI:
# https://pypi.org/project/fastapi/

fastapi>=0.115.0
fastapi-cli>=0.0.3
uvicorn[standard]>=0.32.0
sqlmodel>=0.0.21
sqlalchemy>=2.0.40
alembic>=1.14.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
python-multipart>=0.0.12
email-validator>=2.2.0
pytest>=8.3.2
httpx>=0.27.2

# Установите все зависимости:
pip install -r requirements.txt
```

##### **Шаг 3: Структура первого проекта**

```
fastapi_course/
├── venv/                    # Виртуальное окружение (не коммитится в git)
├── .gitignore               # Игнорируем venv, __pycache__ и т.д.
├── requirements.txt         # Зависимости проекта
└── app/
    ├── __init__.py
    └── main.py              # Основной файл приложения
```

**`.gitignore` (минимальный):**
```gitignore
# Виртуальное окружение
venv/
.env/
.venv/

# Файлы Python
__pycache__/
*.py[cod]
*$py.class

# IDE
.vscode/
.idea/
*.swp
*.swo

# Логи и временные файлы
*.log
*.sqlite
```

##### **Шаг 4: Запуск сервера**

###### **Способ 1: Классический запуск через uvicorn**

```bash
# Базовый запуск
uvicorn app.main:app

# С автоматической перезагрузкой при изменениях (для разработки)
uvicorn app.main:app --reload

# С указанием хоста и порта
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# Подробный вывод логов
uvicorn app.main:app --reload --log-level debug
```

###### **Способ 2: Запуск через FastAPI CLI (самый современный)**

**Вариант A: Для простых файлов**

```bash
# Если ваш основной файл называется main.py и находится в текущей директории
fastapi dev main.py

# Если файл находится в app/main.py:
fastapi dev app.main

# С указанием хоста и порта
fastapi dev main.py --host 0.0.0.0 --port 8000

# С другим уровнем логирования
fastapi dev main.py --log-level debug
```

**Вариант B: Для структурированных проектов**

```
my_project/
├── app/
│   ├── __init__.py
│   └── main.py
└── pyproject.toml
```

```bash
# Укажите путь к модулю
fastapi dev app.main

# Или создайте pyproject.toml для автоматического определения
```

**Создайте `pyproject.toml`:**
```toml
[project]
name = "my-fastapi-app"
version = "0.1.0"

[tool.fastapi]
app = "app.main:app"
```

Теперь можно просто запустить:
```bash
fastapi dev
```

###### **Преимущества `fastapi dev`:**

1. **Автоматическая перезагрузка по умолчанию** - не нужно указывать `--reload`
2. **Встроенный отладчик** - можно использовать `--reload-dir` для отслеживания изменений в нескольких директориях
3. **Более красивые логи** - улучшенное форматирование вывода
4. **Интеграция с pyproject.toml** - единая конфигурация
5. **Единая команда** - проще запомнить

###### **Сравнение всех способов запуска:**

| Способ | Команда | Перезагрузка | Конфигурация | Рекомендация |
|--------|---------|--------------|--------------|--------------|
| **Классический** | `uvicorn main:app --reload` | С флагом `--reload` | Через аргументы | Универсальный |
| **Из Python** | `python run.py` | Зависит от скрипта | В коде Python | Для кастомного запуска |
| **FastAPI CLI** | `fastapi dev main.py` | **По умолчанию!** | pyproject.toml | **Для разработки** |
| **Production** | `uvicorn main:app --workers 4` | Нет | systemd/docker | Для продакшена |

###### **Пример полного workflow с FastAPI CLI:**

```bash
# 1. Создаем проект
mkdir myapi && cd myapi

# 2. Создаем виртуальное окружение
python -m venv venv
source venv/bin/activate  # или .\venv\Scripts\activate на Windows

# 3. Устанавливаем FastAPI
pip install "fastapi[all]"

# 4. Создаем основной файл
cat > main.py << 'EOF'
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
EOF

# Или создайте файл вручную в редакторе

# 5. Запускаем одним простым способом!
fastapi dev main.py
```

###### **Дополнительные команды FastAPI CLI:**

```bash
# Проверка версии
fastapi --version

# Показать help
fastapi --help

# Генерация проекта (экспериментальная функция)
fastapi new myproject

# Запуск в production-режиме (без перезагрузки)
fastapi run main.py
```

###### **Конфигурация через pyproject.toml:**

```toml
[project]
name = "library-api"
version = "0.1.0"
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
]

[tool.fastapi]
# Основное приложение
app = "app.main:app"
# Дополнительные приложения (для монолитов)
apps = [
    {name = "main", app = "app.main:app", port = 8000},
    {name = "admin", app = "app.admin:app", port = 8001},
]

[tool.fastapi.dev]
# Настройки для разработки
host = "0.0.0.0"
port = 8000
reload = true
reload_dirs = ["app", "templates"]
log_level = "info"

[tool.fastapi.production]
# Настройки для продакшена
host = "0.0.0.0"
port = 8000
workers = 4
log_level = "warning"
```

##### **Шаг 5: Расширенный пример первого приложения**

**`app/main.py` с более сложными примерами:**

```python
from fastapi import FastAPI, HTTPException
from typing import Optional, List
from enum import Enum
from datetime import datetime

# Создаем экземпляр приложения с метаданными
app = FastAPI(
    title="FastAPI Learning API",
    description="Это учебное API для изучения FastAPI",
    version="1.0.0",
    docs_url="/docs",  # Можно изменить URL документации
    redoc_url="/redoc",  # Или отключить: docs_url=None
)

# Пример перечисления (Enum) для категорий
class BookCategory(str, Enum):
    FICTION = "fiction"
    NON_FICTION = "non-fiction"
    SCIENCE = "science"
    FANTASY = "fantasy"

# Фиктивная база данных в памяти
fake_books_db = [
    {"id": 1, "title": "Чистый код", "author": "Роберт Мартин", "category": BookCategory.SCIENCE},
    {"id": 2, "title": "1984", "author": "Джордж Оруэлл", "category": BookCategory.FICTION},
    {"id": 3, "title": "Властелин колец", "author": "Дж. Р. Р. Толкин", "category": BookCategory.FANTASY},
]

# Корневой эндпоинт
@app.get("/", tags=["Информация"])
async def read_root():
    """Возвращает приветственное сообщение и информацию об API"""
    return {
        "message": "Добро пожаловать в API библиотеки!",
        "version": app.version,
        "docs": "/docs",
        "endpoints": [
            {"path": "/books", "method": "GET", "description": "Получить все книги"},
            {"path": "/books/{book_id}", "method": "GET", "description": "Получить книгу по ID"},
        ]
    }

# Получение всех книг с фильтрацией
@app.get("/books", tags=["Книги"])
async def get_books(
    category: Optional[BookCategory] = None,
    author: Optional[str] = None,
    limit: int = 10,
    skip: int = 0
):
    """
    Получить список книг с возможностью фильтрации.

    - **category**: Фильтр по категории книги
    - **author**: Фильтр по автору (частичное совпадение)
    - **limit**: Ограничение количества результатов (по умолчанию 10)
    - **skip**: Количество пропущенных результатов (для пагинации)
    """
    result = fake_books_db

    if category:
        result = [book for book in result if book["category"] == category]

    if author:
        result = [book for book in result if author.lower() in book["author"].lower()]

    # Применяем пагинацию
    result = result[skip:skip + limit]

    return result

# Получение книги по ID
@app.get("/books/{book_id}", tags=["Книги"])
async def get_book(book_id: int, details: bool = False):
    """
    Получить книгу по её ID.

    - **book_id**: ID книги (целое число)
    - **details**: Если True, возвращает расширенную информацию
    """
    book = next((book for book in fake_books_db if book["id"] == book_id), None)

    if book is None:
        raise HTTPException(
            status_code=404,
            detail=f"Книга с ID {book_id} не найдена",
            headers={"X-Error": "Book not found"}
        )

    if details:
        # Расширенная информация
        book_with_details = book.copy()
        book_with_details.update({
            "description": "Описание книги...",
            "pages": 350,
            "published_year": 2020
        })
        return book_with_details

    return book

# Эндпоинт с фиксированным значением должен быть ВЫШЕ динамического
@app.get("/books/special", tags=["Книги"])
async def get_special_books():
    """Получить специальные книги"""
    return {"message": "Это специальная секция книг"}

# Проверка состояния сервера (health check)
@app.get("/health", tags=["Система"])
async def health_check():
    """Проверка работоспособности API"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}
```

##### **Шаг 6: Тестирование API**

1. **Запустите сервер:**
```bash
# Если файл в app/main.py:
fastapi dev app.main

# Если файл в корне проекта:
fastapi dev main.py
```

2. **Откройте в браузере:**
   - Документация Swagger UI: `http://localhost:8000/docs`
   - Альтернативная документация: `http://localhost:8000/redoc`

3. **Протестируйте через командную строку (curl):**
```bash
# Получить все книги
curl -X 'GET' 'http://localhost:8000/books' -H 'accept: application/json'

# Получить книгу по ID
curl -X 'GET' 'http://localhost:8000/books/1' -H 'accept: application/json'

# Фильтрация по категории
curl -X 'GET' 'http://localhost:8000/books?category=science' -H 'accept: application/json'

# Проверка здоровья
curl -X 'GET' 'http://localhost:8000/health' -H 'accept: application/json'
```

4. **Или используйте Python для тестирования:**
```python
import httpx
import asyncio

async def test_api():
    async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
        # Тестируем корневой эндпоинт
        response = await client.get("/")
        print("Root:", response.json())

        # Тестируем получение книг
        response = await client.get("/books")
        print("Books:", response.json())

        # Тестируем получение одной книги
        response = await client.get("/books/1")
        print("Book 1:", response.json())

if __name__ == "__main__":
    asyncio.run(test_api())
```
5. **Справка:**

**Path Parameters (Параметры пути):**

Параметры, которые являются частью самого URL.

```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    # FastAPI автоматически валидирует, что user_id можно привести к int
    # Если нет — вернет красивую ошибку 422.
    return {"user_id": user_id}

# Порядок имеет значение! `specific` должна быть раньше, чем `{item_id}`.
@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}

@app.get("/users/{user_id}")
async def read_user(user_id: str):
    return {"user_id": user_id}
```

**Query Parameters (Параметры запроса):**

Параметры, которые передаются после `?` в URL. Используются для фильтрации, пагинации и т.д.

```python
from typing import Optional  # Для объявления необязательных параметров

# Эндпоинт: /items/?skip=0&limit=10
@app.get("/items/")
async def read_items(skip: int = 0, limit: int = 10):
    # Значения по умолчанию задаются прямо в функции.
    # Если параметры не переданы, будут использованы 0 и 10.
    return {"skip": skip, "limit": limit}

# Необязательный параметр
@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Optional[str] = None):
    result = {"item_id": item_id}
    if q:  # Если q был передан в запросе
        result.update({"q": q})
    return result

# Булевые параметры
@app.get("/feature/")
async def is_active(active: bool = False):
    return {"feature_is_active": active}
# FastAPI поймет: /feature/?active=true, /feature/?active=1, /feature/?active=on
```

### **Чек-лист понимания материала:**

Перед выполнением домашнего задания убедитесь, что вы понимаете:

- [ ] Что такое HTTP и как устроены запросы/ответы
- [ ] Основные HTTP-методы и когда их использовать
- [ ] Что такое REST и его основные принципы
- [ ] Как установить и запустить FastAPI приложение
- [ ] Разницу между синхронным и асинхронным кодом
- [ ] Как работают path и query параметры в FastAPI

##### **Домашнее задание**

1. **Настройте окружение** одним из предложенных способов.
2. **Создайте API для управления студентами**:
   - `GET /` - информация об API
   - `GET /students` - список всех студентов (добавьте параметры `course`, `faculty`)
   - `GET /students/{student_id}` - студент по ID
   - `GET /students/top` - топ 5 студентов (фиксированный маршрут)
   - `GET /status` - проверка статуса сервера

3. **Добавьте обработку ошибок** для случая, когда студент не найден.

4. **Экспериментируйте с параметрами запуска**:
   - Запустите сервер на порту 8080
   - Отключите автоматическую перезагрузку
   - Запустите с повышенным уровнем логирования

5. **Изучите документацию**:
   - Проверьте оба варианта: `/docs` и `/redoc`
   - Протестируйте все эндпоинты через Swagger UI
   - Посмотрите, как генерируются примеры запросов

##### **Частые проблемы и решения**

1. **Порт уже занят:**
```bash
# Узнайте, какой процесс использует порт
# На Windows:
netstat -ano | findstr :8000
# На macOS/Linux:
lsof -i :8000

# Или просто запустите на другом порту:
uvicorn app.main:app --port 8001 --reload
```

2. **Модуль не найден:**
```bash
# Убедитесь, что виртуальное окружение активировано
# Переустановите зависимости
pip install --upgrade pip
pip install -r requirements.txt
```

3. **Ошибки импорта:**
```bash
# Запускайте из корневой директории проекта
cd /path/to/fastapi_course
uvicorn app.main:app --reload
```

4. **Не работает автоматическая перезагрузка:**
```bash
# Попробуйте явно указать директорию для отслеживания
uvicorn app.main:app --reload --reload-dir ./app
```

##### **Частые ошибки новичков:**

1. **Забыли активировать виртуальное окружение:**
   ```bash
   # Всегда проверяйте наличие (venv) в начале строки
   (venv) $ pip install fastapi
   ```

2. **Неправильный путь к приложению:**
   ```bash
   # ❌ Неправильно (если файл в app/main.py):
   uvicorn main:app
   
   # ✅ Правильно:
   uvicorn app.main:app
   ```

3. **Использование синхронных операций в async функциях:**
   ```python
   # ❌ Неправильно:
   @app.get("/")
   async def read_root():
       time.sleep(1)  # Блокирует event loop!
       return {"message": "Hello"}
   
   # ✅ Правильно:
   @app.get("/")
   async def read_root():
       await asyncio.sleep(1)  # Не блокирует
       return {"message": "Hello"}
   ```

Эта детальная инструкция позволит вам избежать большинства типичных проблем на старте и сосредоточиться на изучении FastAPI, а не на настройке окружения.



*(Продолжение следует. Далее будет тема по Pydantic и Request Body.)*

---

## **Полезные ресурсы:**

- [Официальная документация FastAPI](https://fastapi.tiangolo.com/)
- [Документация Pydantic v2](https://docs.pydantic.dev/)
- [Документация Uvicorn](https://www.uvicorn.org/)
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- [REST API Best Practices](https://restfulapi.net/)

---

<!--
## Дополнительные рекомендации для дальнейшего улучшения материала:

1. **Добавить интерактивные элементы:**
   - Ссылки на онлайн-инструменты для тестирования API
   - Интерактивные примеры в документации FastAPI

2. **Расширить раздел про REST:**
   - Добавить примеры плохого и хорошего API дизайна
   - Показать типичные анти-паттерны

3. **Добавить раздел про инструменты разработки:**
   - VS Code расширения для FastAPI
   - Настройка линтеров (ruff, black)
   - Pre-commit hooks

4. **Улучшить домашнее задание:**
   - Добавить критерии оценки
   - Предоставить примеры ожидаемого результата
   - Добавить дополнительные задания для продвинутых студентов
-->